# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"Autogenerated return type of AccountPay"
type AccountPayPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  intent: JSON
  success: Boolean!
  transaction: Transaction
}

type Address {
  "City name"
  city: String!
  "Country name"
  country: String!
  "The formatted address string."
  display: [String!]!
  "Place ID, from Google"
  id: ID!
  location: Location!
  "[DEPRECATED] The first part of formated address string.Should contains a street name and building number.If the address does not have street here will be value from secondary field."
  mainText: String!
  "[DEPRECATED] The second part of formatted address string. Should contains city, zip and country.If the address does not have street this field willbe empty and value will be moved to the main field."
  secondaryText: String!
  "Country state name"
  state: String!
  "ZIP code"
  zip: String!
}

"Autogenerated return type of AttachOfflinePayment"
type AttachOfflinePaymentPayload {
  order: Order
  success: Boolean!
  transaction: Transaction
}

"Autogenerated return type of AuthConfirmIdentity"
type AuthConfirmIdentityPayload {
  identity: Identity
  status: String
  success: Boolean!
}

"Autogenerated return type of AuthForgotPassword"
type AuthForgotPasswordPayload {
  status: String
  success: Boolean!
}

"Autogenerated return type of AuthResetPassword"
type AuthResetPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of AuthSignIn"
type AuthSignInPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  driver: Driver
  partner: Partner
  partnerMember: PartnerMember
  refreshToken: String
  success: Boolean!
  superAdmin: SuperAdmin
  supplier: Supplier
  supplierMember: SupplierMember
  token: String
  type: IdentityTypeEnum
}

"Autogenerated return type of AuthValidateResetToken"
type AuthValidateResetTokenPayload {
  success: Boolean!
}

type AvailabilityTimeBlockOff {
  city: City
  date: String!
  from: Int!
  id: ID!
  partner: Partner
  plant: Plant
  product: ProductCategory
  to: Int!
}

"Autogenerated return type of AvailabilityTimeBlockOffCreate"
type AvailabilityTimeBlockOffCreatePayload {
  availabilityTimes: [AvailabilityTimeBlockOff!]
  success: Boolean!
}

"Autogenerated return type of AvailabilityTimeBlockOffDelete"
type AvailabilityTimeBlockOffDeletePayload {
  success: Boolean!
}

type AvailabilityTimeBlockOffList {
  count: Int!
  values: [AvailabilityTimeBlockOff!]!
}

"Autogenerated return type of AvailabilityTimeBlockOffUpdate"
type AvailabilityTimeBlockOffUpdatePayload {
  availabilityTimes: [AvailabilityTimeBlockOff!]
  success: Boolean!
}

type AvailabilityTimes {
  deliveryWindow: Int!
  openedRules: [String!]!
  possibleTimes: [String!]!
  timeStep: Int!
  times: [String!]!
  timezone: String!
  workingHoursLimits: [Int!]!
}

type CareerCandidate {
  email: String!
  id: ID!
}

type CareerCandidateRequest {
  attachment: CareerCandidateResume!
  candidate: CareerCandidate!
  id: ID!
  job: CareerJob!
  message: String
}

type CareerCandidateResume {
  fileName: String!
  id: ID!
  source: String!
}

type CareerJob {
  additionalInfo: String
  description: String
  direction: String!
  experience: String
  id: ID!
  location: String!
  requirements: [String!]!
  responsibilities: [String!]!
  salary: String
  title: String!
  type: String!
}

type CareerJobList {
  count: Int!
  values: [CareerJob!]!
}

type Cart {
  address: Address
  cartItems: [CartItem!]
  contractor: Contractor
  id: ID!
  orders: [CartOrder!]!
  project: Project
  timezone: String
}

"Autogenerated return type of CartClear"
type CartClearPayload {
  cart: Cart!
  success: Boolean!
}

"Autogenerated return type of CartCreateOrders"
type CartCreateOrdersPayload {
  orders: [Order!]!
  success: Boolean!
}

"Autogenerated return type of CartGroupUpdate"
type CartGroupUpdatePayload {
  cart: Cart!
  success: Boolean!
}

type CartItem {
  cart: Cart!
  deliveryDetails: String
  deliveryTime: String
  deliveryWindow: Int
  group: Int!
  id: ID!
  pickup: Boolean!
  plant: Plant
  productTypePrice: ProductTypePrice!
  quantity: Float!
  units: String
  virtualPrice: ProductTypeVirtualPrice
}

"Autogenerated return type of CartItemCreate"
type CartItemCreatePayload {
  cartItem: CartItem!
  success: Boolean!
}

"Autogenerated return type of CartItemRemove"
type CartItemRemovePayload {
  success: Boolean!
}

"Autogenerated return type of CartItemUpdate"
type CartItemUpdatePayload {
  cartItem: CartItem!
  success: Boolean!
}

"Autogenerated return type of CartMerge"
type CartMergePayload {
  cart: Cart!
  success: Boolean!
}

type CartOrder {
  address: Address
  components: [OrderPrice!]!
  deliveryDetails: Int
  deliveryItems: [[OrderDeliveryItem!]!]!
  deliveryTime: String!
  deliveryWindow: Int!
  pickup: Boolean!
  plant: Plant
  totalPrice: Float!
}

type CartPreparatoryConfig {
  availabilityTimes(days: [String!], group: Int!): AvailabilityTimes!
  paymentMethods(projectType: String, provider: [String!]): [PaymentMethod!]!
  processingFees: [OrderPreparatoryConfigFeePrice!]!
}

"Autogenerated return type of CartUpdate"
type CartUpdatePayload {
  cart: Cart!
  success: Boolean!
}

type Channel {
  archived: Boolean!
  contractor: Contractor
  driver: Driver
  id: ID!
  "[DEPRECATED] Timestamp of the last message in channel"
  lastMessage: String
  "The last message in channel"
  lastMessageFull: ChannelMessage
  order: Order
  orderTruck: OrderTruck
  partner: Partner!
  project: Project
  timezone: String
  totalMessages: Int!
  truck: Truck
  unreadMessages: Int!
}

type ChannelList {
  count: Int!
  values: [Channel!]!
}

type ChannelMessage {
  attachments: [Resource!]!
  author: User
  createdAt: String!
  id: ID!
  read: Boolean!
  text: String!
  timezone: String
  type: String!
}

"Autogenerated return type of ChannelMessageCreate"
type ChannelMessageCreatePayload {
  message: ChannelMessage
  success: Boolean!
}

type ChannelMessageList {
  channel: Channel!
  count: Int!
  values: [ChannelMessage!]!
}

"Autogenerated return type of ChannelMessageRead"
type ChannelMessageReadPayload {
  success: Boolean!
}

"City object, describes logical region where locations/products/orders are."
type City {
  "Address object of the city. It usually used to get latitude/longitude."
  address: Address!
  country: Country!
  countryState: CountryStateInstance!
  id: ID!
  "The name of city, same as in Google"
  name: String!
  "Timezone"
  timezone: String
}

"Autogenerated return type of CityCreate"
type CityCreatePayload {
  city: City!
  success: Boolean!
}

type Config {
  currencies: [String!]!
  industries: [String!]!
  tags: [String!]!
  units: [Unit!]!
}

type Contractor {
  account: ContractorAccount
  accounts: [ContractorAccount!]!
  activeStatus: String
  address: Address
  companyInfo: ContractorCompanyInfo!
  customField1: String
  customField2: String
  displayName: String
  earnings: Int
  exportCode: String
  id: ID!
  info: ContractorInfo!
  lockedPartner: Partner
  "[DEPRECATED]"
  members: [ContractorMember!]!
  "List of contractor's members"
  membersP(limit: Int, search: String, skip: Int): ContractorMemberList!
  note: Note
  notes(limit: Int, skip: Int): NoteList
  orders: [Order!]!
  ordersP(limit: Int, skip: Int, status: [OrderStatusEnum!]): OrderListExtended!
  owner: ContractorMember!
  paymentsInfo: ContractorPaymentsInfo!
  prettyId: String!
  priceGroups(cities: [IdInput!], limit: Int, plants: [IdInput!], productTypes: [IdInput!], skip: Int, suppliers: [IdInput!]): ContractorPriceGroupList!
  productTypePrices(cities: [IdInput!], groups: [PriceGroupEnum!], limit: Int, plants: [IdInput!], productTypes: [IdInput!], search: String, skip: Int, suppliers: [IdInput!]): ProductTypePriceList!
  projects: [Project!]!
  referees: [Contractor!]
  referralCode: String
  savedPartners: [Partner!]!
  subscription: SubscriptionInstance!
  testMode: Boolean!
  transactions(limit: Int, skip: Int): TransactionList!
  verified: Boolean!
}

type ContractorAccount {
  allowCreditCard: Boolean!
  allowOffline: Boolean!
  balance: Float!
  credit: Float!
  creditExpiredAt: String
  id: ID!
  name: String!
  offlineBanks: [PartnerAccountBankRequisites!]
  partner: Partner!
  type: String!
}

"Autogenerated return type of ContractorAccountTopUp"
type ContractorAccountTopUpPayload {
  account: ContractorAccount!
  success: Boolean!
}

"Autogenerated return type of ContractorAccountUpdate"
type ContractorAccountUpdatePayload {
  account: ContractorAccount!
  success: Boolean!
}

"Autogenerated return type of ContractorAddDocument"
type ContractorAddDocumentPayload {
  success: Boolean!
}

type ContractorCompanyInfo {
  address: String
  addressDetailed: Address
  logo: String
  name: String
}

"Autogenerated return type of ContractorConfirmIdentity"
type ContractorConfirmIdentityPayload {
  identity: Identity
  status: String
  success: Boolean!
}

"Autogenerated return type of ContractorCreate"
type ContractorCreatePayload {
  contractor: Contractor
  success: Boolean!
}

"Autogenerated return type of ContractorDisconnect"
type ContractorDisconnectPayload {
  success: Boolean!
}

"Autogenerated return type of ContractorForgotPassword"
type ContractorForgotPasswordPayload {
  status: String
  success: Boolean!
}

type ContractorInfo {
  accountingEmail: String
  additional: JSON!
  avatar: String
  country: Country
  name: String
  onboarded: Boolean!
  type: String
}

type ContractorList {
  count: Int!
  values: [Contractor!]!
}

"Autogenerated return type of ContractorManagerAdd"
type ContractorManagerAddPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

"Autogenerated return type of ContractorManagerRemove"
type ContractorManagerRemovePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

"Autogenerated return type of ContractorManagerResetPassword"
type ContractorManagerResetPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of ContractorManagerUpdate"
type ContractorManagerUpdatePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

type ContractorMember {
  contractor: Contractor!
  email: String
  id: ID!
  identities: [Identity!]!
  info: ContractorMemberInfo!
  other: [ContractorMember!]!
  phone: String
  role: String!
  status: String
  statusChangedAt: String
}

type ContractorMemberInfo {
  avatar: String
  name: String
}

type ContractorMemberList {
  count: Int!
  values: [ContractorMember!]!
}

"Autogenerated return type of ContractorMerge"
type ContractorMergePayload {
  success: Boolean!
}

"Autogenerated return type of ContractorNoteUpdate"
type ContractorNoteUpdatePayload {
  note: Note
  success: Boolean!
}

"Autogenerated return type of ContractorPartnerUpdate"
type ContractorPartnerUpdatePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

type ContractorPaymentsInfo {
  defaultMethod: PaymentMethod!
  paymentMethods(partner: IdInput, provider: [String!]): [PaymentMethod!]!
  "[DEPRECATED]"
  savedCards(provider: String): [PaymentMethodCard!]!
  "[DEPRECATED]"
  savedCardsNew(provider: String): [PaymentMethod!]!
}

type ContractorPriceGroup {
  city: City
  group: String!
  plant: Plant
  priority: Int!
  productType: ProductType
  supplier: Supplier
}

type ContractorPriceGroupList {
  count: Int!
  values: [ContractorPriceGroup!]!
}

"Autogenerated return type of ContractorRequestPayment"
type ContractorRequestPaymentPayload {
  success: Boolean!
}

"Autogenerated return type of ContractorResetPassword"
type ContractorResetPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of ContractorSendPassword"
type ContractorSendPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of ContractorSignIn"
type ContractorSignInPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  refreshToken: String
  success: Boolean!
  token: String
}

"Autogenerated return type of ContractorSignUp"
type ContractorSignUpPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  refreshToken: String
  success: Boolean!
  token: String
}

type ContractorSkidList {
  count: Int!
  values: [SkidContractorListInstance!]!
}

"Autogenerated return type of ContractorSkidUpdate"
type ContractorSkidUpdatePayload {
  success: Boolean!
}

"Autogenerated return type of ContractorSubscriptionRequestTrial"
type ContractorSubscriptionRequestTrialPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  subscription: SubscriptionInstance
  success: Boolean!
}

"Autogenerated return type of ContractorUpdate"
type ContractorUpdatePayload {
  addedIdentities: [Identity!]
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

"Autogenerated return type of ContractorValidateResetToken"
type ContractorValidateResetTokenPayload {
  success: Boolean!
}

"Country object"
type Country {
  "The international code of country"
  code: String!
  "The currency used in the country"
  currency: String!
  id: ID!
  "The name of country, same as in Google"
  name: String!
}

type CountryStateInstance {
  "The international code of country state"
  code: String!
  country: Country!
  id: ID!
  "The name of country state, same as in Google"
  name: String!
}

type CountryStateList {
  count: Int!
  values: [CountryStateInstance!]!
}

type CsvExport {
  csv: String
  job: JobStatus
}

type Dashboard {
  activeContractors: DashboardActiveContractors!
  contractors: DashboardContractors!
  monthlyRevenue(currency: String): DashboardMonthlyRevenue!
  orders: DashboardOrdersRanges!
  ordersDaily(from: String!, to: String!): [DashboardOrdersDaily!]!
}

type DashboardActiveContractors {
  last30Days: Int!
  lastMonth: Int!
}

type DashboardContractors {
  last30Days: Int!
  lastMonth: Int!
  total: Int!
}

type DashboardMonthlyRevenue {
  currency: String!
  total: Float!
}

type DashboardOrders {
  active: Int!
  delivered: Int!
  total: Int!
}

type DashboardOrdersDaily {
  count: Int!
  date: String!
}

type DashboardOrdersRanges {
  last30Days: DashboardOrders!
  lastMonth: DashboardOrders!
  total: DashboardOrders!
}

type DeliveryMethod {
  caption: String
  description: String
  id: ID!
  image: String
  name: String!
}

"Autogenerated return type of DeliveryMethodCreate"
type DeliveryMethodCreatePayload {
  deliveryMethod: DeliveryMethod
  success: Boolean!
}

"Autogenerated return type of DeliveryMethodDelete"
type DeliveryMethodDeletePayload {
  success: Boolean!
}

type DeliveryMethodList {
  count: Int!
  values: [DeliveryMethod!]!
}

"Autogenerated return type of DeliveryMethodUpdate"
type DeliveryMethodUpdatePayload {
  deliveryMethod: DeliveryMethod
  success: Boolean!
}

type Driver {
  blockOff(date: String!): Boolean
  city: City
  color: String!
  driverBlockOffs: [DriverBlockOff!]
  id: ID!
  identities: [Identity!]!
  info: DriverInfo!
  location: Location
  note: Note
  notes(limit: Int, skip: Int): NoteList
  orders: [OrderTruck!]!
  partner: Partner
  pending: Boolean!
  plants: [Plant!]!
  prettyId: String!
  trucks: [Truck!]!
  workingDay: WorkingDay
  workingDays(limit: Int, skip: Int): DriverWorkingDayList!
}

type DriverBlockOff {
  active: Boolean!
  category: DriverBlockOffEnum
  driver: Driver!
  from: Int!
  id: ID!
  note: String
  to: Int
}

"Autogenerated return type of DriverBlockOffCreate"
type DriverBlockOffCreatePayload {
  driverBlockOff: DriverBlockOff
  success: Boolean!
}

"Autogenerated return type of DriverBlockOffDelete"
type DriverBlockOffDeletePayload {
  success: Boolean!
}

"Autogenerated return type of DriverBlockOffUpdate"
type DriverBlockOffUpdatePayload {
  driverBlockOff: DriverBlockOff!
  success: Boolean!
}

"Autogenerated return type of DriverCompleteDay"
type DriverCompleteDayPayload {
  success: Boolean!
  workingDay: WorkingDay!
}

"Autogenerated return type of DriverConfirmIdentity"
type DriverConfirmIdentityPayload {
  driver: Driver
  identity: Identity
  status: String
  success: Boolean!
}

"Autogenerated return type of DriverCreate"
type DriverCreatePayload {
  driver: Driver
  success: Boolean!
}

"Autogenerated return type of DriverDisconnect"
type DriverDisconnectPayload {
  success: Boolean!
}

"Autogenerated return type of DriverForgotPassword"
type DriverForgotPasswordPayload {
  status: String
  success: Boolean!
}

type DriverInfo {
  avatar: String
  name: String
  role: String
}

type DriverList {
  count: Int!
  values: [Driver!]!
}

"Autogenerated return type of DriverNoteUpdate"
type DriverNoteUpdatePayload {
  note: Note
  success: Boolean!
}

"Autogenerated return type of DriverRemove"
type DriverRemovePayload {
  success: Boolean!
}

"Autogenerated return type of DriverResetPassword"
type DriverResetPasswordPayload {
  success: Boolean!
}

type DriverRoute {
  active: Boolean!
  id: ID!
  orderTruck: OrderTruck
  route: String
  status: String!
  workingDay: WorkingDay!
}

type DriverRouteList {
  count: Int!
  values: [DriverRoute!]!
}

"Autogenerated return type of DriverSignIn"
type DriverSignInPayload {
  driver: Driver
  refreshToken: String
  success: Boolean!
  token: String
}

"Autogenerated return type of DriverSignUp"
type DriverSignUpPayload {
  driver: Driver
  success: Boolean!
  token: String
}

"Autogenerated return type of DriverStartDay"
type DriverStartDayPayload {
  success: Boolean!
  workingDay: WorkingDay!
}

"Autogenerated return type of DriverUpdate"
type DriverUpdatePayload {
  addedIdentities: [Identity!]
  driver: Driver
  success: Boolean!
}

"Autogenerated return type of DriverUpdatePosition"
type DriverUpdatePositionPayload {
  success: Boolean!
}

"Autogenerated return type of DriverValidateResetToken"
type DriverValidateResetTokenPayload {
  success: Boolean!
}

type DriverWorkingDayList {
  count: Int!
  values: [WorkingDay!]!
}

type ExportFile {
  url: String
}

type ExportResult {
  file: ExportFile
  job: JobStatus
}

type FavoriteProductTypes {
  count: Int!
  values: [ProductTypeLike!]!
}

type Fee {
  availablePriceContent: [String!]!
  code: String
  createdAt: String!
  deliveryMethods: [DeliveryMethod!]!
  details: FeeDetails!
  exportCode: String
  id: ID!
  mergeName: String
  name: String!
  pickup: String!
  product: ProductCategory
  productTypes: [ProductType!]!
  productTypesP(limit: Int, plant: IdInput, skip: Int): ProductTypeList!
  serviceName: String!
  sortOrder: Int!
  taxable: Boolean!
  type: String!
  updatedAt: String!
  useAfterSubtotal: Boolean
  zeroOut: Boolean
}

"Autogenerated return type of FeeCreate"
type FeeCreatePayload {
  fee: Fee
  success: Boolean!
}

type FeeDetails {
  algorithm: String
  amountFrom: String
  amountTo: String
  distanceFrom: Float
  distanceTo: Float
  durationFrom: Float
  durationTo: Float
  from: String
  multiplier: Float
  provider: String
  quantityFrom: String
  quantitySequence: String
  quantityTo: String
  rrule: String
  to: String
  useAfterTax: Boolean
}

type FeeList {
  count: Int!
  values: [Fee!]!
}

type FeePrice {
  fee: Fee!
  permissions: FeePricePermissions!
  price: Price!
}

"Autogenerated return type of FeePriceCreate"
type FeePriceCreatePayload {
  feePrice: Price
  success: Boolean!
}

type FeePricePermissions {
  canDelete: Boolean!
}

"Autogenerated return type of FeePriceUpdate"
type FeePriceUpdatePayload {
  feePrice: FeePrice
  success: Boolean!
}

"Autogenerated return type of FeeUpdate"
type FeeUpdatePayload {
  fee: Fee
  success: Boolean!
}

type Formula {
  id: ID!
  name: String!
  requiredArguments: [String!]
  value: String!
}

type FormulaList {
  count: Int!
  values: [Formula!]!
}

type GalleryList {
  count: Int!
  values: [OrderImage!]!
}

type GlobalMapList {
  orders: [OrderCluster!]!
  plants: [PlantCluster!]!
  trucks: [OrderTruckCluster!]!
}

type Identity {
  confirmed: Boolean!
  id: ID!
  provider: String!
  uid: String!
}

"Autogenerated return type of InternalCandidateRequestCreate"
type InternalCandidateRequestCreatePayload {
  candidateRequest: CareerCandidateRequest
  success: Boolean!
}

type Inventory {
  id: ID!
  inventoryTransactions: [InventoryTransaction!]
  plant: Plant!
  productType: ProductType!
  quantity: Int
}

"Autogenerated return type of InventoryAdd"
type InventoryAddPayload {
  inventory: Inventory!
  success: Boolean!
}

type InventoryList {
  count: Int!
  values: [Inventory!]!
}

"Autogenerated return type of InventoryRemove"
type InventoryRemovePayload {
  inventory: Inventory!
  success: Boolean!
}

type InventoryTransaction {
  createdAt: String!
  id: ID!
  inventory: Inventory!
  quantity: Int!
  type: String!
}

type Invite {
  contractor: InviteContractorInfo
  id: ID!
  partner: InvitePartnerInfo
  pending: Boolean!
  redirectTo: String
  status: String!
  targetContractor: Contractor
  targetDriver: Driver
  targetMember: Member
  type: String!
}

"Autogenerated return type of InviteConfirm"
type InviteConfirmPayload {
  success: Boolean!
}

type InviteContractorInfo {
  companyInfo: ContractorCompanyInfo!
  id: ID!
  info: ContractorInfo!
}

type InvitePartnerInfo {
  address: Address
  appAndroidUrl: String!
  appIosUrl: String!
  banner: String
  caption: String
  code: String
  countryState: CountryStateInstance!
  description: String
  email: String
  hasApp: Boolean!
  id: ID!
  inviteContractorBanner: String
  inviteManagerBanner: String
  largeLogo: String
  logo: String
  name: String!
  phone: String
  qrAppUrl: String
  qrDriverUrl: String
  shortCaption: String
  website: String
}

"Autogenerated return type of InviteReject"
type InviteRejectPayload {
  success: Boolean!
}

type JobStatus {
  id: String!
  lastUpdate: String!
  message: String
  payload: JSON
  percent: Int
  progress: Int
  status: String!
  total: Int
}

type JobStatusList {
  count: Int!
  values: [JobStatus!]!
}

type Location {
  latitude: Float!
  longitude: Float!
}

type MeInfo {
  clientStore: String
  contractor: Contractor
  contractorMember: ContractorMember
  driver: Driver
  info: User
  partner: Partner
  partnerMember: PartnerMember
  permissions: JSON!
  service: MeService
  settings: JSON!
  superAdmin: SuperAdmin
  supplier: Supplier
  supplierMember: SupplierMember
  type: IdentityTypeEnum
}

type MeService {
  hubspotToken: String
}

type Member {
  active: Boolean!
  avatar: String
  email: String
  id: ID!
  identities: [Identity!]!
  identity: Identity
  name: String!
  role: String!
}

type Mutation {
  accountPay(payment: PaymentInput!): AccountPayPayload!
  authConfirmIdentity(email: String, phone: String, token: String, type: IdentityTypeEnum!): AuthConfirmIdentityPayload!
  authForgotPassword(email: String, phone: String, type: IdentityTypeEnum!): AuthForgotPasswordPayload!
  authResetPassword(email: String, newPassword: String!, phone: String, resetToken: String!, type: IdentityTypeEnum!): AuthResetPasswordPayload!
  authSignIn(email: IdentityEmailInput, oauth: IdentityOauth2Input, partner: IdInput, phone: IdentityPhoneInput, type: IdentityTypeEnum!): AuthSignInPayload!
  authValidateResetToken(email: String, phone: String, resetToken: String!, type: IdentityTypeEnum!): AuthValidateResetTokenPayload!
  availabilityBlockOffCreate(input: [AvailabilityTimeBlockOffCreateInput!]!): AvailabilityTimeBlockOffCreatePayload!
  availabilityBlockOffDelete(input: [IdInput!]!): AvailabilityTimeBlockOffDeletePayload!
  availabilityBlockOffUpdate(advanced: Boolean, input: [AvailabilityTimeBlockOffUpdateInput!]!): AvailabilityTimeBlockOffUpdatePayload!
  cartClear(cart: IdInput): CartClearPayload!
  cartCreateOrders(cart: IdInput, deliveryDetails: [String!], paymentMethod: IdInput, projectType: String): CartCreateOrdersPayload!
  cartGroupUpdate(cart: IdInput, group: Int, input: CartGroupUpdate!): CartGroupUpdatePayload!
  cartItemCreate(cart: IdInput, input: CartItemCreate!): CartItemCreatePayload!
  cartItemRemove(cartItem: IdInput!): CartItemRemovePayload!
  cartItemUpdate(cartItem: IdInput!, input: CartItemUpdate!): CartItemUpdatePayload!
  cartMerge(
    "Temporary Cart which should be merged to contractor's cart"
    cart: IdInput!
  ): CartMergePayload!
  cartUpdate(cart: IdInput, input: CartUpdate!): CartUpdatePayload!
  channelMessageCreate(attachments: [ResourceInput!], channel: IdInput!, text: String!): ChannelMessageCreatePayload!
  channelMessageRead(channel: IdInput!, messages: [IdInput!]!): ChannelMessageReadPayload!
  cityCreate(countryCode: String!, countryStateCode: String!, name: String!): CityCreatePayload!
  contractorAccountTopUp(account: IdInput!, amount: Float!, description: String): ContractorAccountTopUpPayload!
  contractorAccountUpdate(account: IdInput!, credit: Float, due: Float): ContractorAccountUpdatePayload!
  contractorAddDocument(document: Upload!): ContractorAddDocumentPayload!
  contractorConfirmIdentity(email: String, phone: String, token: String): ContractorConfirmIdentityPayload!
  contractorCreate(accountingEmail: String, companyAddress: String, companyName: String, companySize: String, contractorType: String, country: IdInput, creditAccount: Boolean, creditLimit: Float, customField1: String, customField2: String, email: String!, exportCode: String, name: String, password: String, phone: String!, priceGroup: PriceGroupEnum): ContractorCreatePayload!
  contractorDisconnect: ContractorDisconnectPayload!
  contractorForgotPassword(email: String, phone: String): ContractorForgotPasswordPayload!
  contractorManagerAdd(contractor: IdInput, email: String!, name: String, phone: String): ContractorManagerAddPayload!
  contractorManagerRemove(manager: IdInput!): ContractorManagerRemovePayload!
  contractorManagerResetPassword(manager: IdInput!): ContractorManagerResetPasswordPayload!
  contractorManagerUpdate(identity: IdentityUpdateInput, info: ContractorMemberUpdateInfo, manager: IdInput!): ContractorManagerUpdatePayload!
  contractorMerge(destination: IdInput!, source: IdInput!): ContractorMergePayload!
  contractorNoteUpdate(contractor: IdInput!, text: String): ContractorNoteUpdatePayload!
  contractorPartnerUpdate(partner: IdInput!, selected: Boolean!): ContractorPartnerUpdatePayload!
  contractorPaymentRequest(contractor: IdInput!, order: IdInput!): ContractorRequestPaymentPayload!
  contractorResetPassword(contractor: IdInput, email: String, newPassword: String, phone: String, resetToken: String): ContractorResetPasswordPayload!
  contractorSendPassword(contractor: IdInput!): ContractorSendPasswordPayload!
  contractorSignIn(contractor: IdInput, email: IdentityEmailInput, oauth: IdentityOauth2Input, phone: IdentityPhoneInput): ContractorSignInPayload!
  contractorSignUp(identity: ContractorIdentityInputData, info: ContractorUpdateInfoInput, referralCode: String, source: ContractorSourceInputData): ContractorSignUpPayload!
  contractorSkidUpdate(contractor: IdInput!, input: [ContractorSkidUpdateInput!]!, reason: SkidTransactionReasonEnum!): ContractorSkidUpdatePayload!
  contractorSubscriptionRequestTrial: ContractorSubscriptionRequestTrialPayload!
  contractorUpdate(companyInfo: ContractorUpdateCompanyInfoInput, contractor: IdInput, credit: Float, identity: IdentityUpdateInput, info: ContractorUpdateInfoInput, paymentsInfo: ContractorUpdatePaymentsInfoInput, priceGroups: [ContractorPriceGroupCreateInput!], productTypePrices: [ProductTypePriceCreateInput!]): ContractorUpdatePayload!
  contractorValidateResetToken(email: String, phone: String, resetToken: String!): ContractorValidateResetTokenPayload!
  deliveryMethodCreate(input: DeliveryMethodCreateInput!): DeliveryMethodCreatePayload!
  deliveryMethodDelete(input: IdInput!): DeliveryMethodDeletePayload!
  deliveryMethodUpdate(input: DeliveryMethodUpdateInput!): DeliveryMethodUpdatePayload!
  driverCompleteDay(input: DriverWorkingDayInput!, workingDay: IdInput!): DriverCompleteDayPayload!
  driverConfirmIdentity(email: String, phone: String, token: String): DriverConfirmIdentityPayload!
  driverCreate(email: String!, info: DriverInfoInput, phone: String!): DriverCreatePayload!
  driverCreateBlockOff(category: DriverBlockOffEnum, driver: IdInput!, from: String!, note: String, to: String): DriverBlockOffCreatePayload!
  driverDeleteBlockOff(id: ID!): DriverBlockOffDeletePayload!
  driverDisconnect: DriverDisconnectPayload!
  driverForgotPassword(email: String, phone: String): DriverForgotPasswordPayload!
  driverNoteUpdate(driver: IdInput!, text: String): DriverNoteUpdatePayload!
  driverRemove(driver: IdInput!): DriverRemovePayload!
  driverResetPassword(email: String, newPassword: String!, phone: String, resetToken: String!): DriverResetPasswordPayload!
  driverSignIn(email: IdentityEmailInput, phone: IdentityPhoneInput): DriverSignInPayload!
  driverSignUp(identity: DriverIdentityInputData!): DriverSignUpPayload!
  driverStartDay(input: DriverWorkingDayInput!): DriverStartDayPayload!
  driverUpdate(driver: IdInput, identity: IdentityUpdateInput, info: DriverInfoInput): DriverUpdatePayload!
  driverUpdateBlockOff(category: DriverBlockOffEnum, driverBlockOff: IdInput!, from: String, note: String, to: String): DriverBlockOffUpdatePayload!
  driverUpdatePosition(location: LocationInput!): DriverUpdatePositionPayload!
  driverValidateResetToken(email: String, phone: String, resetToken: String!): DriverValidateResetTokenPayload!
  feeCreate(fee: FeeCreateInput!): FeeCreatePayload!
  feePriceCreate(feePrice: FeePriceInput!): FeePriceCreatePayload!
  feePriceUpdate(input: FeePriceUpdateInput!): FeePriceUpdatePayload!
  feeUpdate(input: FeeUpdateInput!): FeeUpdatePayload!
  financeSetExported(partnerFinance: IdInput, partnerFinances: [IdInput!], value: Boolean): PartnerFinanceSetExportedPayload!
  financeSetInvoiced(partnerFinance: IdInput!, value: Boolean): PartnerFinanceSetInvoicedPayload!
  financeSetPaid(partnerFinance: IdInput!, value: Boolean): PartnerFinanceSetPaidPayload!
  internalCandidateRequestCreate(candidate: CareerCandidateInput!, job: IdInput!, requestPayload: CareerCandidateRequestCreateInput!): InternalCandidateRequestCreatePayload!
  inventoryAdd(input: InventoryInput!): InventoryAddPayload!
  inventoryRemove(input: InventoryInput!): InventoryRemovePayload!
  inviteConfirm(city: IdInput, country: IdInput, email: String, invite: IdInput!, name: String, password: String, phone: String): InviteConfirmPayload!
  inviteReject(invite: IdInput!): InviteRejectPayload!
  optionCreate(from: IdInput, input: OptionCreateInput, supplier: IdInput): OptionCreatePayload!
  optionPriceCreate(optionPrice: OptionPriceInput!): OptionPriceCreatePayload!
  optionPriceUpdate(input: OptionPriceUpdateInput!): OptionPriceUpdatePayload!
  optionUpdate(input: OptionUpdateInput!, supplier: IdInput): OptionUpdatePayload!
  orderAcceptQuote(deliveryTime: String, order: IdInput!, quiet: Boolean): OrderAcceptQuotePayload!
  orderAddPaymentMethod(order: IdInput!, paymentCard: PaymentMethodCardInput, paymentMethod: ID, provider: String!, update: Boolean): OrderAddPaymentMethodPayload!
  orderAlertClose(alerts: [IdInput!]!, order: IdInput!): OrderAlertClosePayload!
  orderArchiveChange(change: IdInput!): OrderArchiveChangePayload!
  orderAskForPayment(order: IdInput!): OrderAskForPaymentPayload!
  orderAskToConfirm(order: IdInput!, quiet: Boolean): OrderAskToConfirmPayload!
  orderAttachOfflinePayment(amount: Float!, date: String, description: String, offlineType: TransactionOfflineTypeEnum, order: IdInput): AttachOfflinePaymentPayload!
  orderBook(order: IdInput!, quiet: Boolean): OrderBookPayload!
  orderCancel(order: IdInput, quiet: Boolean, reason: OrderCancelReasonType, token: String): OrderCancelPayload!
  orderChargeManually(order: IdInput!): OrderChargeManuallyPayload!
  orderClone(deliveryTime: String!, order: IdInput!): OrderClonePayload!
  orderComplete(order: IdInput, quiet: Boolean, token: String): OrderCompletePayload!
  orderConfirm(order: IdInput!, quiet: Boolean): OrderConfirmPayload!
  orderCreate(contractor: IdInput, contractorMember: IdInput, draft: Boolean, order: OrderCreateInput, partner: IdInput, payment: PaymentInput, plant: IdInput, quiet: Boolean, quote: Boolean, supplier: IdInput): OrderCreatePayload!
  orderDeliveringDone(order: IdInput!, quiet: Boolean): OrderDeliveringDonePayload!
  orderDeliveringStarted(order: IdInput!, quiet: Boolean): OrderDeliveringStartedPayload!
  "DEPRECATED"
  orderDriverNoteAdd(note: String!, order: IdInput!, truckIndex: Int): OrderDriverNoteAddPayload!
  "DEPRECATED"
  orderDriverNoteRemove(noteIndices: [Int!]!, order: IdInput!, truckIndex: Int): OrderDriverNoteRemovePayload!
  "DEPRECATED"
  orderDriverNoteUpdate(note: String!, noteIndex: Int!, order: IdInput!, truckIndex: Int): OrderDriverNoteUpdatePayload!
  orderGenerateDeliverySlip(order: IdInput!): OrderGenerateDeliverySlipPayload!
  orderGenerateInvoice(order: IdInput!): OrderGenerateInvoicePayload!
  orderHold(order: IdInput!, quiet: Boolean): OrderHoldPayload!
  orderImageAdd(image: OrderImageInput, images: [OrderImageInput!], order: IdInput!): OrderImageAddPayload!
  orderImageRemove(images: [IdInput!]!, order: IdInput!): OrderImageRemovePayload!
  orderLive(order: IdInput!, quiet: Boolean): OrderLivePayload!
  orderMessageCreate(order: IdInput!, text: String!): OrderMessageCreatePayload!
  orderMessageRead(messages: [IdInput!]!, order: IdInput!): OrderMessageReadPayload!
  orderNoteUpdate(order: IdInput!, text: String): OrderNoteUpdatePayload!
  orderPay(contractor: IdInput, force: Boolean, order: IdInput, payment: PaymentInput!, replacePaymentMethod: Boolean, token: String): OrderPayPayload!
  orderPickupDone(order: IdInput!): OrderPickupDonePayload!
  orderPickupStarted(order: IdInput!, quiet: Boolean): OrderPickupStartedPayload!
  orderRate(order: OrderRateInput!): OrderRatePayload!
  orderReadChange(changes: [IdInput!], groups: [OrderChangeGroupEnum!], order: IdInput!): OrderReadChangePayload!
  orderReadyToPickup(order: IdInput!, pickupTime: String, quiet: Boolean): OrderReadyToPickupPayload!
  orderRefreshQuote(deliveryTime: String, order: IdInput!): OrderRefreshQuotePayload!
  orderReject(order: IdInput!, quiet: Boolean, reason: RejectReasonEnum!, time: String): OrderRejectPayload!
  orderRelease(order: IdInput!, quiet: Boolean): OrderReleasePayload!
  orderRemovePaymentMethod(order: IdInput!): OrderRemovePaymentMethodPayload!
  orderResourceAdd(order: IdInput!, resources: [OrderResourceInput!]!): OrderResourceAddPayload!
  orderResourceRemove(order: IdInput!, resources: [IdInput!]!): OrderResourceRemovePayload!
  orderRestore(order: IdInput!, quiet: Boolean): OrderRestorePayload!
  orderSendInvoice(order: IdInput!): OrderSendInvoicePayload!
  orderSendNotification(order: IdInput!, type: OrderTruckStatusEnum!): OrderSendNotificationPayload!
  orderTaxZeroOut(orderPrice: IdInput!, zeroOut: Boolean!): OrderTaxZeroOutPayload!
  orderTransactionCancel(transaction: IdInput!): OrderTransactionCancelPayload!
  orderTransactionCapture(transaction: IdInput!): OrderTransactionCapturePayload!
  "Update delivery list to order truck"
  orderTruckDeliveryListUpdate(deliveryItems: [OrderDeliveryItemInput!], orderTruck: IdInput!): OrderTruckDeliveryListUpdatePayload!
  orderTruckNoteAdd(attachments: [ResourceInput!], global: Boolean, orderTruck: IdInput!, text: String): OrderTruckNoteAddPayload!
  orderTruckNoteRemove(note: IdInput!): OrderTruckNoteRemovePayload!
  orderTruckOnSiteJobComplete(orderTruck: IdInput!, pto: Float, quantity: Float): OrderTruckOnSiteJobCompletePayload!
  orderTruckOnSiteJobStart(orderTruck: IdInput!, pto: Float): OrderTruckOnSiteJobStartPayload!
  "Add pin drop to order truck"
  orderTruckPinDropAdd(address: AddressInput!, description: String, image: ResourceInput, orderTruck: IdInput!): OrderTruckPinDropAddPayload!
  "Add signature to order truck"
  orderTruckSignatureAdd(author: String, orderTruck: IdInput!, signature: ResourceInput, skip: Boolean): OrderTruckSignatureAddPayload!
  orderTruckUpdate(arrivedAt: String, deliveredAt: String, deliveryTime: String, driver: IdInput, onsiteJobCompletedAt: String, onsiteJobStartedAt: String, orderTruck: IdInput!, plant: IdInput, ptoOnComplete: Float, ptoOnStart: Float, quantitySecondary: Float, removeDriver: Boolean, removeTruck: Boolean, returningAt: String, startedAt: String, timeGapAfter: Int, timeGapBefore: Int, timeGapOnsite: Int, truck: IdInput): OrderTruckUpdatePayload!
  orderUpdate(advancedMode: Boolean, askToConfirm: Boolean, contractorMember: IdInput, order: OrderUpdateInput!, payment: PaymentInput, plant: IdInput, quiet: Boolean): OrderUpdatePayload!
  orderUpdateAdditionalInfo(additional: JSON!, askToConfirm: Boolean, order: IdInput!, quiet: Boolean): OrderUpdateAdditionalInfoPayload!
  orderValidate(contractorMember: IdInput, order: OrderValidateInput!, partner: IdInput, plant: IdInput): OrderValidatePayload!
  orderWaitingForPickup(order: IdInput!, quiet: Boolean): OrderWaitingForPickupPayload!
  partnerAccountPayout(amount: Float!, partner: IdInput!): PartnerAccountPayoutPayload!
  partnerAccountRequestPayout(transactions: [IdInput!]!): PartnerAccountRequestPayoutPayload!
  partnerAccountStripeOnboarding(accountType: String!): PartnerAccountStripeOnboardingPayload!
  partnerContractorAccept(contractor: IdInput!): PartnerContractorAcceptPayload!
  partnerContractorAccountRequest(partner: IdInput!): PartnerContractorAccountRequestPayload!
  partnerContractorBilldRequest: PartnerContractorBilldRequestPayload!
  partnerContractorCancel(contractor: IdInput, partner: IdInput): PartnerContractorCancelPayload!
  partnerContractorConnect(input: [PartnerContractorConnectInput!]!): PartnerContractorConnectPayload!
  partnerContractorDeletePrices(contractor: IdInput!): PartnerContractorDeletePricesPayload!
  partnerContractorInvite(async: Boolean, input: [PartnerContractorInviteInput!]!): PartnerContractorInvitePayload!
  partnerContractorInviteResend: PartnerContractorInviteResendPayload!
  partnerContractorPriceAdded(contractor: IdInput!, value: Boolean): PartnerContractorPriceAddedPayload!
  partnerContractorPriceRequest(partner: IdInput!): PartnerContractorPriceRequestPayload!
  partnerContractorQuoteRequest(order: IdInput!, partner: IdInput!): PartnerContractorQuoteRequestPayload!
  partnerContractorReject(contractor: IdInput!): PartnerContractorRejectPayload!
  partnerContractorUpdate(accountInfo: String, partnerContractor: IdInput!): PartnerContractorUpdatePayload!
  partnerCreate(input: PartnerCreateInput!): PartnerCreatePayload!
  partnerDriverInvite(input: [PartnerDriverInviteInput!]!): PartnerDriverInvitePayload!
  partnerMemberCreate(input: PartnerMemberCreateInput!): PartnerMemberCreatePayload!
  partnerMemberRemove(input: IdInput!): PartnerMemberRemovePayload!
  partnerMemberResetPassword(input: IdInput): PartnerMemberResetPasswordPayload!
  partnerMemberUpdate(input: CommonMemberUpdateInput!): PartnerMemberUpdatePayload!
  partnerTaxCreate(input: PartnerTaxCreateInput!): PartnerTaxCreatePayload!
  partnerTaxRemove(partnerTax: IdInput!): PartnerTaxRemovePayload!
  partnerTaxToggleAvalara(enabled: Boolean!): PartnerTaxToggleAvalaraPayload!
  partnerTaxUpdate(input: PartnerTaxUpdateInput!): PartnerTaxUpdatePayload!
  partnerTaxZeroOut(contractor: IdInput, fee: IdInput!, project: IdInput, zeroOut: Boolean!): PartnerTaxZeroOutPayload!
  partnerUpdate(input: PartnerUpdateInput!): PartnerUpdatePayload!
  paymentCreate(amount: Int!, currency: String!, source: String!): PaymentCreatePayload!
  paymentLinkCancel(paymentLink: IdInput!): PaymentLinkCancelPayload!
  paymentLinkCreate(input: PaymentLinkCreateInput!): PaymentLinkCreatePayload!
  paymentLinkPay(payment: PaymentInput!, paymentLink: IdInput!): PaymentLinkPayPayload!
  paymentLinkSend(emails: [String!], paymentLink: IdInput!, phones: [String!]): PaymentLinkSendPayload!
  paymentMethodPrepare(contractor: IdInput, provider: String!, token: String): PaymentMethodPreparePayload!
  paymentMethodSave(card: PaymentMethodCardInput!, contractor: IdInput, forFutureUse: Boolean, provider: PaymentMethodProviderEnum!, token: String): PaymentMethodSavePayload!
  paymentPrepareCard(contractor: IdInput, provider: String!): PaymentPrepareCardPayload!
  plantCreate(input: PlantCreateInput): PlantCreatePayload!
  plantDeliveryMethodRemove(category: IdInput!, deliveryMethod: IdInput!, plant: IdInput!): PlantDeliveryMethodRemovePayload!
  plantProductCreate(category: IdInput!, plant: IdInput!): PlantProductCreatePayload!
  plantProductDelete(category: IdInput!, plant: IdInput!): PlantProductDeletePayload!
  plantProductUpdate(active: Boolean, category: IdInput!, plant: IdInput!): PlantProductUpdatePayload!
  plantRemove(plant: IdInput!): PlantRemovePayload!
  plantUpdate(input: PlantUpdateInput): PlantUpdatePayload!
  plantUpdateOptions(options: [PlantOptionInput!]!, plant: IdInput!): PlantUpdateOptionsPayload!
  plantUpdateProductDecorates(plant: IdInput!, productDecorates: [PlantProductDecorateInput!]!): PlantUpdateProductDecoratesPayload!
  plantUpdateProductTypes(plant: IdInput!, productTypes: [PlantProductTypeInput!]!): PlantUpdateProductTypesPayload!
  productCategoryBatchUpdate(input: [ProductCategoryUpdateInput!]!, partner: IdInput, supplier: IdInput): ProductCategoryBatchUpdatePayload!
  productCategoryCreate(from: IdInput, input: ProductCategoryCreateInput, partner: IdInput, supplier: IdInput): ProductCategoryCreatePayload!
  productCategoryDelete(input: IdInput!, supplier: IdInput): ProductCategoryDeletePayload!
  productCategoryUpdate(input: ProductCategoryUpdateInput!, partner: IdInput, supplier: IdInput): ProductCategoryUpdatePayload!
  productDecorateBatchUpdate(input: [ProductDecorateUpdateInput!]!, supplier: IdInput): ProductDecorateBatchUpdatePayload!
  productDecorateCreate(from: IdInput, input: ProductDecorateCreateInput, supplier: IdInput): ProductDecorateCreatePayload!
  productDecoratePriceCreate(input: ProductDecoratePriceCreateInput!): ProductDecoratePriceCreatePayload!
  productDecoratePriceUpdate(input: ProductDecoratePriceUpdateInput!): ProductDecoratePriceUpdatePayload!
  productDecorateUpdate(input: ProductDecorateUpdateInput!, supplier: IdInput): ProductDecorateUpdatePayload!
  productDependenciesRemove(category: IdInput!): ProductDependenciesRemovePayload!
  productTypeBatchUpdate(input: [ProductTypeUpdateInput!]!, partner: IdInput, supplier: IdInput): ProductTypeBatchUpdatePayload!
  productTypeCreate(from: IdInput, input: ProductTypeCreateInput, partner: IdInput, supplier: IdInput): ProductTypeCreatePayload!
  productTypeCreateCustom(address: AddressInput!, input: ProductTypeCreateCustomInput!, partner: IdInput): ProductTypeCreateCustomPayload!
  productTypeLike(productTypes: [IdInput!]!): ProductTypeLikePayload!
  productTypePriceCreate(input: ProductTypePriceCreateInput!): ProductTypePriceCreatePayload!
  productTypePriceDelete(input: ProductTypePriceUpdateInput!): ProductTypePriceDeletePayload!
  productTypePriceUpdate(input: ProductTypePriceUpdateInput!): ProductTypePriceUpdatePayload!
  productTypeUnlike(productTypes: [IdInput!]!): ProductTypeUnlikePayload!
  productTypeUpdate(input: ProductTypeUpdateInput!, partner: IdInput, supplier: IdInput): ProductTypeUpdatePayload!
  projectComplete(project: IdInput!): ProjectCompletePayload!
  projectCreate(contractor: IdInput, input: ProjectCreateInput!): ProjectCreatePayload!
  projectImageAdd(images: [ProjectImageInput!]!, project: IdInput!): ProjectImageAddPayload!
  projectImageRemove(images: [IdInput!]!, project: IdInput!): ProjectImageRemovePayload!
  projectNoteAdd(note: String!, project: IdInput!): ProjectNoteAddPayload!
  projectNoteRemove(noteIndices: [Int!]!, project: IdInput!): ProjectNoteRemovePayload!
  projectNoteUpdate(note: String!, noteIndex: Int!, project: IdInput!): ProjectNoteUpdatePayload!
  projectPricesUpdate(input: ProjectPricesUpdateInput): ProjectPricesUpdatePayload!
  projectQuoteAccept(note: String, project: IdInput!, resource: Upload!): ProjectQuoteAcceptPayload!
  projectQuoteRequest(project: IdInput!): ProjectQuoteRequestPayload!
  projectRemove(project: IdInput!): ProjectRemovePayload!
  projectResourceAdd(project: IdInput!, resources: [ProjectResourceInput!]!): ProjectResourceAddPayload!
  projectResourceRemove(project: IdInput!, resources: [IdInput!]!): ProjectResourceRemovePayload!
  projectStart(project: IdInput!): ProjectStartPayload!
  projectUpdate(input: ProjectUpdateInput!): ProjectUpdatePayload!
  projectUpdatePriceGroups(priceGroups: [ProjectPriceGroupCreateInput!], project: IdInput!): ProjectUpdatePriceGroupsPayload!
  questionaryAnswerSave(answers: JSON!, reason: QuestionaryReasonEnum!, targetInput: QuestionaryTargetInput!): QuestionaryAnswerSavePayload!
  serviceRequestInfo(input: ServiceRequestInfoInput!): ServiceRequestInfoPayload!
  skidTransactionDelete(input: IdInput!): SkidTransactionDeletePayload!
  supplierCreate(input: SupplierCreateInput!): SupplierCreatePayload!
  supplierMemberCreate(input: SupplierMemberCreateInput!): SupplierMemberCreatePayload!
  supplierMemberRemove(input: IdInput!): SupplierMemberRemovePayload!
  supplierMemberResetPassword(input: IdInput): SupplierMemberResetPasswordPayload!
  supplierMemberUpdate(input: CommonMemberUpdateInput!): SupplierMemberUpdatePayload!
  supplierUpdate(input: SupplierUpdateInput!): SupplierUpdatePayload!
  transactionSetExported(transaction: IdInput, transactions: [IdInput!], value: Boolean): TransactionSetExportedPayload!
  truckAccept(order: IdInput!, truck: IdInput!): TruckAcceptPayload!
  truckArrive(order: IdInput!, truck: IdInput!): TruckArrivePayload!
  truckCancel(order: IdInput!, truck: IdInput!): TruckCancelPayload!
  truckComplete(order: IdInput!, truck: IdInput!): TruckCompletePayload!
  truckCreate(input: TruckCreateInput!): TruckCreatePayload!
  truckNoteUpdate(text: String, truck: IdInput!): TruckNoteUpdatePayload!
  truckRemove(input: TruckRemoveInput!): TruckRemovePayload!
  truckReturn(order: IdInput!, truck: IdInput!): TruckReturnPayload!
  truckRevert(order: IdInput!, truck: IdInput!): TruckRevertPayload!
  truckStart(order: IdInput!, quiet: Boolean, truck: IdInput!): TruckStartPayload!
  truckUpdate(input: TruckUpdateInput!): TruckUpdatePayload!
  userSetClientStore(value: String!): UserSetClientStorePayload!
  widgetCreate(input: WidgetCreateInput!): WidgetCreatePayload!
  widgetDelete(id: ID!): WidgetDeletePayload!
  widgetUpdate(input: WidgetUpdateInput!): WidgetUpdatePayload!
}

type Note {
  attachments: [Resource!]!
  author: User
  createdAt: String!
  id: ID!
  read: Boolean!
  text: String!
  timezone: String
  type: String!
}

type NoteList {
  count: Int!
  values: [Note!]!
}

type Option {
  category: ProductCategory!
  customized: Boolean!
  exportCode: String
  group: String!
  id: ID!
  image: String
  max: Float
  min: Float
  name: String!
  oneOfGroup: Boolean!
  partner: Partner
  required: Boolean!
  serviceName: String!
  sortOrder: Int!
  step: Float
  taxable: Boolean!
}

"Autogenerated return type of OptionCreate"
type OptionCreatePayload {
  option: Option
  success: Boolean!
}

type OptionList {
  count: Int!
  groups: [String]!
  values: [Option!]!
}

type OptionPrice {
  group: String
  option: Option!
  price: Price!
}

"Autogenerated return type of OptionPriceCreate"
type OptionPriceCreatePayload {
  optionPrice: Price
  success: Boolean!
}

type OptionPricePaginatedInstance {
  option: Option!
  prices: [OptionPrice!]!
}

type OptionPricePaginatedList {
  count: Int!
  groups: [String!]!
  values: [OptionPricePaginatedInstance!]!
}

"Autogenerated return type of OptionPriceUpdate"
type OptionPriceUpdatePayload {
  optionPrice: OptionPrice
  success: Boolean!
}

"Autogenerated return type of OptionUpdate"
type OptionUpdatePayload {
  option: Option
  success: Boolean!
}

type Order {
  additional: JSON!
  address: Address!
  adminNote: Note
  adminNotes: String!
  alerts: [OrderAlert!]!
  askForPayment: Boolean
  availableActions: [String!]!
  changesInfo: OrderChangesInfo!
  chargedManually: Boolean!
  city: City!
  contractor: Contractor!
  contractorMember: ContractorMember
  contractorNote: Note
  countryState: CountryStateInstance!
  currency: String!
  customPrices: Boolean!
  deliveredAt: String
  deliveryDetails: String!
  deliveryMethod: DeliveryMethod!
  deliveryTime: String!
  deliveryWindow: Int!
  driverNotes: [OrderDriverNotes!]!
  fees: [Fee!]!
  hasToBeRated: Boolean!
  history: OrderHistory!
  holdLimits: Int!
  id: ID!
  images: [OrderImage!]!
  "Link to order invoice"
  invoice: String
  invoiceTotalPrice: Float!
  lastPaymentFailureReason: String
  link: String
  linkToPayment: String
  lockToCancelTime: String!
  lockToUpdateTime: String!
  notes(limit: Int, skip: Int, type: IdentityTypeEnum): NoteList
  "[DEPRECATED]"
  number: ID!
  options: [Option!]!
  origin: String!
  partner: Partner
  partnerContractor: PartnerContractor
  paymentIntents(all: Boolean): [PaymentIntent!]!
  paymentLinkPossibleValue: Float!
  paymentMethod(legacy: Boolean): PaymentMethod
  paymentMethodSource: JSON
  paymentMode: String!
  paymentStatus: String!
  pendingPossibleTime: Boolean
  permissions: JSON!
  pickup: Boolean
  pickupTime: String
  plant: Plant!
  pouringTime: String!
  prettyId: String!
  priceMode: String!
  prices: [OrderPrice!]!
  processingFees: [OrderProcessingFeeInstance!]!
  product: ProductCategory!
  project: Project
  projectType: String!
  purchaseNumber: String
  quantity: Float!
  quantitySecondary: Float!
  ratings: OrderRatings!
  rejectedDetails: OrderRejectedDetails
  resources(limit: Int, skip: Int, types: [OrderResourceTypeEnum!]): OrderResourceList!
  route: Route!
  secondaryUnits: String
  skids: [Skid!]!
  source: String
  sourceInfo: SourceInfo
  status(detailed: Boolean): String!
  supplier: Supplier!
  supplierDeliveryInstructions: String!
  testMode: Boolean!
  timeBetweenTrucks: Int!
  timeRequestedWithTruck: Int!
  timezone: String!
  totalPaid: Float!
  totalPaidProcessingFee: Float!
  totalPrice: Float!
  "[DEPRECATED]"
  transactions(limit: Int, skip: Int): TransactionList!
  truckStatus: String!
  trucks: [Float!]!
  trucksConfig: TrucksConfig!
  trucksDrivers: [OrderTruck!]!
  trucksSecondary: [Float!]!
  units: String
  unloadingMethod: String!
  unloadingMethodDetails: String!
  updatedAt: String!
}

"Autogenerated return type of OrderAcceptQuote"
type OrderAcceptQuotePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderAddPaymentMethod"
type OrderAddPaymentMethodPayload {
  paymentMethod: PaymentMethod
  success: Boolean!
}

type OrderAlert {
  action: OrderAlertTypeAction!
  id: String!
  level: String!
  message: String!
}

"Autogenerated return type of OrderAlertClose"
type OrderAlertClosePayload {
  success: Boolean!
}

type OrderAlertTypeAction {
  name: String!
  type: String!
}

"Autogenerated return type of OrderArchiveChange"
type OrderArchiveChangePayload {
  success: Boolean!
}

"Autogenerated return type of OrderAskForPayment"
type OrderAskForPaymentPayload {
  success: Boolean!
}

"Autogenerated return type of OrderAskToConfirm"
type OrderAskToConfirmPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderBook"
type OrderBookPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderCancel"
type OrderCancelPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  order: Order
  success: Boolean!
}

type OrderChange {
  archived: Boolean!
  change: JSON!
  createdAt: String!
  id: ID!
  order: Order!
  source: String!
  type: String!
  viewed: Boolean!
}

type OrderChanges {
  count: Int!
  values: [OrderChange!]!
}

type OrderChangesInfo {
  changeAddress: Int!
  changeDeliveryTime: Int!
  changeProduct: Int!
  changeTrucks: Int!
  countUnread: Int!
}

"Autogenerated return type of OrderChargeManually"
type OrderChargeManuallyPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderClone"
type OrderClonePayload {
  order: Order!
  success: Boolean!
}

type OrderCluster {
  count: Int!
  id: ID!
  location: Location!
  value: Order
  values: [OrderClusterValue!]!
}

type OrderClusterValue {
  id: ID!
}

"Autogenerated return type of OrderComplete"
type OrderCompletePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderConfirm"
type OrderConfirmPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderCreate"
type OrderCreatePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderDeliveringDone"
type OrderDeliveringDonePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderDeliveringStarted"
type OrderDeliveringStartedPayload {
  order: Order
  success: Boolean!
}

type OrderDeliveryItem {
  id: ID
  productType: ProductType!
  quantity: Float!
  status: DeliveryItemStatusEnum
}

"Autogenerated return type of OrderDriverNoteAdd"
type OrderDriverNoteAddPayload {
  success: Boolean!
}

"Autogenerated return type of OrderDriverNoteRemove"
type OrderDriverNoteRemovePayload {
  success: Boolean!
}

"Autogenerated return type of OrderDriverNoteUpdate"
type OrderDriverNoteUpdatePayload {
  success: Boolean!
}

type OrderDriverNotes {
  id: ID
  notes: [String!]!
}

"Autogenerated return type of OrderGenerateDeliverySlip"
type OrderGenerateDeliverySlipPayload {
  success: Boolean!
  url: String!
}

"Autogenerated return type of OrderGenerateInvoice"
type OrderGenerateInvoicePayload {
  success: Boolean!
  url: String!
}

type OrderHistory {
  initial: OrderHistoryItem!
  updates: [OrderHistoryItem!]!
}

type OrderHistoryItem {
  data: JSON!
  time: String!
  timezone: String
}

"Autogenerated return type of OrderHold"
type OrderHoldPayload {
  order: Order
  success: Boolean!
}

type OrderImage {
  contractorMember: ContractorMember
  createdAt: String!
  driver: Driver
  id: ID!
  image: Resource!
  type: String!
}

"Autogenerated return type of OrderImageAdd"
type OrderImageAddPayload {
  image: OrderImage
  images: [OrderImage!]
  success: Boolean!
}

"Autogenerated return type of OrderImageRemove"
type OrderImageRemovePayload {
  success: Boolean!
}

type OrderList {
  count: Int!
  values: [Order!]!
}

type OrderListExtended {
  clusters(precision: Float!): [OrderCluster!]!
  count: Int!
  values: [Order!]!
}

"Autogenerated return type of OrderLive"
type OrderLivePayload {
  order: Order
  success: Boolean!
}

type OrderMessage {
  createdAt: String!
  id: ID!
  read: Boolean!
  text: String!
  type: String!
}

"Autogenerated return type of OrderMessageCreate"
type OrderMessageCreatePayload {
  message: OrderMessage
  success: Boolean!
}

type OrderMessageList {
  count: Int!
  order: Order!
  values: [OrderMessage!]!
}

"Autogenerated return type of OrderMessageRead"
type OrderMessageReadPayload {
  success: Boolean!
}

"Autogenerated return type of OrderNoteUpdate"
type OrderNoteUpdatePayload {
  note: Note
  success: Boolean!
}

"Autogenerated return type of OrderPay"
type OrderPayPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  intent: JSON
  order: Order
  success: Boolean!
  transaction: Transaction
}

"Autogenerated return type of OrderPickupDone"
type OrderPickupDonePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderPickupStarted"
type OrderPickupStartedPayload {
  order: Order
  success: Boolean!
}

type OrderPreparatoryConfig {
  availabilityTimes(days: [String!], pickupTime: Boolean): AvailabilityTimes!
  availableProductTypes(keepPlant: Boolean): [ProductType!]!
  cities(region: RegionInput, search: String, withPossibles: Boolean): [City!]
  countries: [Country!]!
  fees(currency: String, deliveryMethod: String, filter: Boolean, mergeWithExisting: Boolean, types: [FeeTypeEnum!], withPossibles: Boolean): [OrderPreparatoryConfigFeePrice!]!
  options(currency: String): [OrderPreparatoryConfigOptionPrice!]!
  partners: [Partner!]!
  paymentMethods(projectType: String, provider: [String!]): [PaymentMethod!]!
  pickup: Boolean!
  plantConfig: PlantConfigInstance
  plants(pickup: Boolean, region: RegionInput, supplier: IdInput, withPossibles: Boolean): [Plant!]!
  plantsGeofence(pickup: Boolean, region: RegionInput, withPossibles: Boolean): [String!]!
  """

  returns (pickup)plants with
  the quantity of explicit product type
  """
  plantsInventory(productType: IdInput!, region: RegionInput, withPossibles: Boolean): [PlantInventoryList!]!
  processingFees(currency: String): [OrderPreparatoryConfigFeePrice!]!
  productDecorates(currency: String, productTypePrice: IdInput): [OrderPreparatoryConfigProductDecoratePrice!]!
  productTypes(currency: String, keepPlant: Boolean, limit: Int, perSupplier: Boolean, productType: IdInput, search: String, skip: Int, withCombinations: Boolean): [OrderPreparatoryConfigProductTypePrice!]!
  products(region: RegionInput, withPossibles: Boolean): [ProductCategory!]!
  quantitiesConfig(productType: IdInput!): QuantitiesConfig!
  route: Route!
  skids: [OrderPreparatoryConfigSkidPrice!]!
  supplierDeliveryInstructions: String
  taxFromZeroOuted(taxPrice: IdInput!): OrderPreparatoryConfigFeePrice!
  taxZeroOuted(taxPrice: IdInput!): OrderPreparatoryConfigFeePrice!
  taxes(currency: String, internal: Boolean): [OrderPreparatoryConfigFeePrice!]!
  totalPrice(currency: String): OrderPreparatoryConfigTotalPrice!
  trucksConfig: TrucksConfig!
  trucksConfigs: [TrucksConfig!]!
}

type OrderPreparatoryConfigFeePrice {
  fee: Fee!
  price: Price!
}

type OrderPreparatoryConfigOptionPrice {
  option: Option!
  price: Price!
}

type OrderPreparatoryConfigProductDecoratePrice {
  price: Price!
  productDecorate: ProductDecorate!
}

type OrderPreparatoryConfigProductTypePrice {
  price: Price!
  priceMode: OrderPriceModeEnum
  productType: ProductType!
  supplier: Supplier
  units: String!
  virtualPrice: ProductTypeVirtualPrice
}

type OrderPreparatoryConfigSkidPrice {
  price: Price!
  quantity: Int!
  skid: Skid!
  totalPrice: Float
}

type OrderPreparatoryConfigTotalPrice {
  components: [OrderPrice!]!
  value: Float!
}

type OrderPrice {
  anchorPrice: OrderPrice
  fee: Fee
  id: ID
  option: Option
  price: Price!
  productDecorate: ProductDecorate
  productType: ProductType
  quantity: Float
  skid: Skid
  units: String
  value: Float!
  virtualPrice: ProductTypeVirtualPrice
}

type OrderProcessingFeeInstance {
  fee: Fee
  value: Float
}

"Autogenerated return type of OrderRate"
type OrderRatePayload {
  order: Order
  success: Boolean!
}

type OrderRatings {
  brokrete: Int
  driver: Int
  product: Int
  supplier: Int
}

"Autogenerated return type of OrderReadChange"
type OrderReadChangePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderReadyToPickup"
type OrderReadyToPickupPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderRefreshQuote"
type OrderRefreshQuotePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderReject"
type OrderRejectPayload {
  order: Order
  success: Boolean!
}

type OrderRejectedDetails {
  description: String!
  reason: String!
  time: String
}

"Autogenerated return type of OrderRelease"
type OrderReleasePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderRemovePaymentMethod"
type OrderRemovePaymentMethodPayload {
  success: Boolean!
}

type OrderResource {
  createdAt: String!
  id: ID!
  resource: Resource!
  type: String
}

"Autogenerated return type of OrderResourceAdd"
type OrderResourceAddPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  resources: [OrderResource!]
  success: Boolean!
}

type OrderResourceList {
  count: Int!
  values: [OrderResource!]!
}

"Autogenerated return type of OrderResourceRemove"
type OrderResourceRemovePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

"Autogenerated return type of OrderRestore"
type OrderRestorePayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderSendInvoice"
type OrderSendInvoicePayload {
  success: Boolean!
}

"Autogenerated return type of OrderSendNotification"
type OrderSendNotificationPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderTaxZeroOut"
type OrderTaxZeroOutPayload {
  order: Order!
  success: Boolean!
}

"Autogenerated return type of OrderTransactionCancel"
type OrderTransactionCancelPayload {
  success: Boolean!
  transaction: Transaction
}

"Autogenerated return type of OrderTransactionCapture"
type OrderTransactionCapturePayload {
  success: Boolean!
  transaction: Transaction
}

type OrderTruck {
  actualRoute: String
  additional: JSON
  arrivedAt: String
  deliveredAt: String
  deliveryItems: [OrderDeliveryItem!]!
  deliveryTime: String
  driver: Driver
  estimatedDuration: Int
  eta: String
  "Link to order truck eticket"
  eticket: String
  heading: Float
  "[DEPRECATED] Truck index in the order"
  id: Int!
  location: Location
  notes: [String!]!
  notesNew: OrderTruckNoteList!
  onsiteJobCompletedAt: String
  onsiteJobStartedAt: String
  order: Order
  permissions: JSON!
  pinDrop: OrderTruckPinDrop
  plannedRoute: String
  plannedRouteDuration: Int
  plannedRouteVersion: Int
  plant: Plant
  ptoOnComplete: Float
  ptoOnStart: Float
  quantity: Float!
  quantitySecondary: Float
  returningAt: String
  routeDetails: JSON
  signature: OrderTruckSignature!
  startedAt: String
  status: String!
  "The time (in min) it takes for a truck to return back"
  timeGapAfter: Int
  "The time (in min) it takes for a truck to get on site"
  timeGapBefore: Int
  "The time (in min) it takes for a truck to do job on site"
  timeGapOnsite: Int
  truck: Truck
  "Truck UUID"
  truckId: ID!
  updatedAt: String!
}

type OrderTruckCluster {
  count: Int!
  id: ID!
  location: Location!
  value: OrderTruck
  values: [OrderTruckClusterValue!]!
}

type OrderTruckClusterValue {
  id: ID!
}

"Autogenerated return type of OrderTruckDeliveryListUpdate"
type OrderTruckDeliveryListUpdatePayload {
  success: Boolean!
  truck: OrderTruck
}

type OrderTruckList {
  count: Int!
  values: [OrderTruck!]!
}

type OrderTruckNote {
  attachments: [Resource!]!
  author: User
  createdAt: String!
  id: ID!
  read: Boolean!
  text: String!
  timezone: String
  type: String!
}

"Autogenerated return type of OrderTruckNoteAdd"
type OrderTruckNoteAddPayload {
  note: OrderTruckNote
  notes: [OrderTruckNote!]!
  success: Boolean!
}

type OrderTruckNoteList {
  count: Int!
  values: [OrderTruckNote!]!
}

"Autogenerated return type of OrderTruckNoteRemove"
type OrderTruckNoteRemovePayload {
  success: Boolean!
}

"Autogenerated return type of OrderTruckOnSiteJobComplete"
type OrderTruckOnSiteJobCompletePayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of OrderTruckOnSiteJobStart"
type OrderTruckOnSiteJobStartPayload {
  success: Boolean!
  truck: OrderTruck
}

type OrderTruckPinDrop {
  address: Address
  description: String
  image: Resource
}

"Autogenerated return type of OrderTruckPinDropAdd"
type OrderTruckPinDropAddPayload {
  success: Boolean!
  truck: OrderTruck
}

type OrderTruckSignature {
  author: String
  image: Resource
  status: String
}

"Autogenerated return type of OrderTruckSignatureAdd"
type OrderTruckSignatureAddPayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of OrderTruckUpdate"
type OrderTruckUpdatePayload {
  orderTruck: OrderTruck!
  success: Boolean!
}

"Autogenerated return type of OrderUpdateAdditionalInfo"
type OrderUpdateAdditionalInfoPayload {
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderUpdate"
type OrderUpdatePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  order: Order
  success: Boolean!
}

"Autogenerated return type of OrderValidate"
type OrderValidatePayload {
  errorReason: String
  success: Boolean!
}

"Autogenerated return type of OrderWaitingForPickup"
type OrderWaitingForPickupPayload {
  order: Order
  success: Boolean!
}

type Partner {
  account: PartnerAccount
  address: Address
  appAndroidUrl: String!
  appIosUrl: String!
  banner: String
  caption: String
  code: String
  config: PartnerConfig
  countryState: CountryStateInstance!
  description: String
  driverAppAndroidUrl: String!
  driverAppIosUrl: String!
  email: String
  hasApp: Boolean!
  hasCreditAccount: Boolean!
  id: ID!
  inviteContractorBanner: String
  inviteManagerBanner: String
  largeLogo: String
  logo: String
  mainAppVisible: Boolean!
  members(limit: Int, skip: Int): PartnerMemberList
  name: String
  paid: Boolean!
  permissions: JSON!
  phone: String
  plants(limit: Int, skip: Int): PlantList
  prettyIdPrefix: String
  productCategories(limit: Int, skip: Int): ProductCategoryList
  qrAppUrl: String
  qrDriverUrl: String
  shortCaption: String
  signatureConsentText: String
  subscription: SubscriptionInstance!
  suppliers(limit: Int, skip: Int): SupplierList
  taxes: [Fee!]!
  termsAndConditions: String
  timezone: String
  website: String
}

type PartnerAccount {
  balance: Float!
  currency: String!
  fundsAvailablePeriod: Int
  offlineBanks: [PartnerAccountBankRequisites!]
  partner: Partner!
  paymentHandling: String
  payoutFeeAdminCoef: Float
  payoutFeeAppCoef: Float
  payoutFeeWebCoef: Float
  stripeOnboardingProgress: String
  transactions(limit: Int, skip: Int): PartnerAccountTransactionList!
}

type PartnerAccountBankRequisites {
  accountHolderName: String
  accountNumber: String
  bankNumber: String
  routingNumber: String
}

"Autogenerated return type of PartnerAccountPayout"
type PartnerAccountPayoutPayload {
  success: Boolean!
}

"Autogenerated return type of PartnerAccountRequestPayout"
type PartnerAccountRequestPayoutPayload {
  success: Boolean!
}

type PartnerAccountStatsConfig {
  fundsAvailablePeriod: Int!
  payoutFeeAdminCoef: Float!
  payoutFeeAppCoef: Float!
  payoutFeePartnerAppCoef: Float!
  payoutFeeWebCoef: Float!
}

type PartnerAccountStatsInstance {
  admin: PartnerAccountStatsSource!
  app: PartnerAccountStatsSource!
  brokrete: PartnerAccountStatsSource!
  config: PartnerAccountStatsConfig!
  csvUrl: String
  partnerApp: PartnerAccountStatsSource!
  storefront: PartnerAccountStatsSource!
  total: PartnerAccountStatsValues!
  web: PartnerAccountStatsSource!
}

type PartnerAccountStatsSource {
  available: Float!
  graph: [JSON!]!
  readyForPayout: Float!
  total: Float!
  totalByAccount: Float!
}

type PartnerAccountStatsValues {
  available: Float!
  readyForPayout: Float!
  total: Float!
  totalByAccount: Float!
}

"Autogenerated return type of PartnerAccountStripeOnboarding"
type PartnerAccountStripeOnboardingPayload {
  success: Boolean!
  url: String!
}

type PartnerAccountTransactionInstance {
  amount: Float!
  order: Order
  partnerAccount: PartnerAccount!
  payoutAvailableAt: String
  source: JSON
  status: String!
}

type PartnerAccountTransactionList {
  count: Int!
  values: [PartnerAccountTransactionInstance!]!
}

type PartnerClientConfigInstance {
  name: String!
  value: String
}

type PartnerClientConfigList {
  count: Int!
  values: [PartnerClientConfigInstance!]!
}

type PartnerConfig {
  notificationEmail: String
  notificationPhone: String
  oneSignalApiKey: String
  oneSignalAppId: String
  serviceEmail: String
  servicePhone: String
  slackBilldWebhookUrl: String
  slackOrderWebhookUrl: String
}

type PartnerContractor {
  accountInfo: String
  accountStatus: PartnerContractorAccountStatusEnum!
  billdStatus: PartnerContractorBilldStatusEnum!
  contractor: Contractor!
  createdAt: String!
  id: ID!
  locked: Boolean
  onboardingCompleted: Boolean!
  owner: Boolean!
  partner: Partner!
  priceAdded: Boolean!
  priceDetails: PartnerContractorPriceDetails!
  priceMode: String!
  priceStatus: PartnerContractorPriceStatusEnum!
  selected: Boolean!
  source: PartnerContractorSourceEnum!
  sourceString: String
  status: PartnerContractorStatusEnum!
  statusChangedAt: String!
}

"Autogenerated return type of PartnerContractorAccept"
type PartnerContractorAcceptPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorAccountRequest"
type PartnerContractorAccountRequestPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorBilldRequest"
type PartnerContractorBilldRequestPayload {
  success: Boolean!
}

"Autogenerated return type of PartnerContractorCancel"
type PartnerContractorCancelPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorConnect"
type PartnerContractorConnectPayload {
  partnerContractors: [PartnerContractor!]!
  success: Boolean!
}

"Autogenerated return type of PartnerContractorDeletePrices"
type PartnerContractorDeletePricesPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorInvite"
type PartnerContractorInvitePayload {
  contractors: [Contractor!]
  job: JobStatus
  success: Boolean!
}

"Autogenerated return type of PartnerContractorInviteResend"
type PartnerContractorInviteResendPayload {
  success: Boolean!
}

type PartnerContractorList {
  count: Int!
  values: [PartnerContractor!]!
}

"Autogenerated return type of PartnerContractorPriceAdded"
type PartnerContractorPriceAddedPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

type PartnerContractorPriceDetails {
  groups: Int!
  personal: Int!
}

"Autogenerated return type of PartnerContractorPriceRequest"
type PartnerContractorPriceRequestPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorQuoteRequest"
type PartnerContractorQuoteRequestPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorReject"
type PartnerContractorRejectPayload {
  partnerContractor: PartnerContractor
  success: Boolean!
}

"Autogenerated return type of PartnerContractorUpdate"
type PartnerContractorUpdatePayload {
  partnerContractor: PartnerContractor!
  success: Boolean!
}

"Autogenerated return type of PartnerCreate"
type PartnerCreatePayload {
  partner: Partner
  success: Boolean!
}

type PartnerDriver {
  driver: Driver!
  partner: Partner!
  source: String
  status: String!
}

type PartnerDriverInviteList {
  driver: Driver
  invite: Invite
}

"Autogenerated return type of PartnerDriverInvite"
type PartnerDriverInvitePayload {
  success: Boolean!
  values: [PartnerDriverInviteList!]!
}

type PartnerDriverList {
  count: Int!
  values: [PartnerDriver!]!
}

type PartnerFinance {
  amount: Float!
  availableActions: [String!]!
  createdAt: String
  creditStatus: String
  creditTerm: Int
  currency: String!
  exported: Boolean
  id: ID!
  invoiced: Boolean
  linkedPayouts: [PartnerPayoutInstance!]
  offline: Boolean
  order: Order!
  origin: String
  paid: Boolean
  partner: Partner!
  payout: Float
  payoutFeeAmount: Float
  payoutFeeTax: Float
  payoutMode: String!
  payoutRate: Float!
  platformFee: Float
  processingFeeAmount: Float
  processingFeeTax: Float
  processingRate: Float!
  source: String!
  status: String!
}

type PartnerFinanceList {
  count: Int!
  values: [PartnerFinance!]!
}

"Autogenerated return type of PartnerFinanceSetExported"
type PartnerFinanceSetExportedPayload {
  partnerFinance: PartnerFinance
  partnerFinances: [PartnerFinance!]
  success: Boolean!
}

"Autogenerated return type of PartnerFinanceSetInvoiced"
type PartnerFinanceSetInvoicedPayload {
  partnerFinance: PartnerFinance!
  success: Boolean!
}

"Autogenerated return type of PartnerFinanceSetPaid"
type PartnerFinanceSetPaidPayload {
  partnerFinance: PartnerFinance!
  success: Boolean!
}

type PartnerList {
  availableCategories: [ProductCategory!]!
  count: Int!
  values: [Partner!]!
}

type PartnerMember {
  active: Boolean!
  avatar: String
  email: String
  id: ID!
  identities: [Identity!]!
  identity: Identity
  name: String!
  partner: Partner!
  role: String!
  roles: [Role!]
  status: String
  statusChangedAt: String
}

"Autogenerated return type of PartnerMemberCreate"
type PartnerMemberCreatePayload {
  member: PartnerMember!
  success: Boolean!
}

type PartnerMemberList {
  count: Int!
  values: [PartnerMember!]!
}

"Autogenerated return type of PartnerMemberRemove"
type PartnerMemberRemovePayload {
  success: Boolean!
}

"Autogenerated return type of PartnerMemberResetPassword"
type PartnerMemberResetPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of PartnerMemberUpdate"
type PartnerMemberUpdatePayload {
  member: PartnerMember!
  success: Boolean!
}

type PartnerPayoutInstance {
  amount: Float!
  availableActions: [String!]!
  createdAt: String!
  currency: String!
  externalLink: String
  finances: [PartnerFinance!]!
  id: ID!
  number: ID!
  paidOutAt: String
  partner: Partner!
  prettyId: String!
  status: String!
  transactions: [Transaction!]!
  updatedAt: String!
  warning: Boolean!
}

type PartnerPayoutList {
  count: Int!
  values: [PartnerPayoutInstance!]!
}

type PartnerTax {
  countryState: CountryStateInstance
  fee: Fee!
  id: ID!
  internal: Boolean!
  system: String!
  visible: Boolean!
}

"Autogenerated return type of PartnerTaxCreate"
type PartnerTaxCreatePayload {
  partnerTax: PartnerTax
  success: Boolean!
}

type PartnerTaxList {
  count: Int!
  values: [PartnerTax!]!
}

"Autogenerated return type of PartnerTaxRemove"
type PartnerTaxRemovePayload {
  success: Boolean!
}

"Autogenerated return type of PartnerTaxToggleAvalara"
type PartnerTaxToggleAvalaraPayload {
  success: Boolean!
}

"Autogenerated return type of PartnerTaxUpdate"
type PartnerTaxUpdatePayload {
  partnerTax: PartnerTax
  success: Boolean!
}

"Autogenerated return type of PartnerTaxZeroOut"
type PartnerTaxZeroOutPayload {
  success: Boolean!
}

"Autogenerated return type of PartnerUpdate"
type PartnerUpdatePayload {
  partner: Partner
  success: Boolean!
}

"Autogenerated return type of PaymentCreate"
type PaymentCreatePayload {
  success: Boolean!
}

type PaymentIntent {
  active: Boolean!
  amount: Float
  availableActions: [String!]!
  createdAt: String!
  currency: String
  id: ID!
  mode: String!
  order: Order
  paymentLink: PaymentLink
  paymentTransaction: Transaction
  prettyId: String!
  processingAmount: Float
  status: String!
  statusChangedAt: String
  updatedAt: String!
}

type PaymentLink {
  amount: Float!
  contractor: Contractor
  createdAt: String!
  currency: String!
  expiredAt: String
  id: ID!
  items: [PaymentIntent!]!
  link: String!
  partner: Partner
  paymentMethods: [PaymentLinkPaymentMethodInstance!]
  paymentTransaction: Transaction
  prettyId: String
  processingAmount: Float
  processingFees(paymentProvider: String): [PaymentLinkProcessingFeeInstance!]
  status: String!
  statusChangedAt: String!
  updatedAt: String!
}

"Autogenerated return type of PaymentLinkCancel"
type PaymentLinkCancelPayload {
  paymentLink: PaymentLink
  success: Boolean!
}

"Autogenerated return type of PaymentLinkCreate"
type PaymentLinkCreatePayload {
  paymentLink: PaymentLink
  success: Boolean!
}

type PaymentLinkList {
  count: Int!
  values: [PaymentLink!]!
}

"Autogenerated return type of PaymentLinkPay"
type PaymentLinkPayPayload {
  clientSecret: String
  intent: JSON
  paymentLink: PaymentLink
  success: Boolean!
  transaction: Transaction
}

type PaymentLinkPaymentMethodInstance {
  paymentMethod: PaymentMethod!
  processingFee: PaymentLinkProcessingFeeInstance
}

type PaymentLinkProcessingFeeInstance {
  fee: Fee
  value: Float
}

"Autogenerated return type of PaymentLinkSend"
type PaymentLinkSendPayload {
  success: Boolean!
}

type PaymentMethod {
  account: ContractorAccount
  card: PaymentMethodCard
  id: ID
  provider: String
}

type PaymentMethodCard {
  brand: String
  cardholderName: String
  country: String
  expMonth: Int
  expYear: Int
  id: ID
  last4: String
  provider: String
  uid: String
  zip: String
}

"Autogenerated return type of PaymentMethodPrepare"
type PaymentMethodPreparePayload {
  data: JSON!
  success: Boolean!
}

"Autogenerated return type of PaymentMethodSave"
type PaymentMethodSavePayload {
  paymentMethod: PaymentMethod!
  success: Boolean!
}

"Autogenerated return type of PaymentPrepareCard"
type PaymentPrepareCardPayload {
  card: JSON!
  success: Boolean!
}

type Plant {
  address: Address!
  city: City!
  color: String!
  customFields: [PlantCustomField!]
  deliveryMethods(category: IdInput): [PlantDeliveryMethod!]!
  deliveryMethodsP(category: IdInput, limit: Int, search: String, skip: Int): PlantDeliveryMethodList!
  deliveryRadius: Float!
  deliveryRadiusUnit: String
  description: String
  discounts(category: IdInput): [PlantDiscount!]!
  email: String
  feePrices(category: IdInput, limit: Int, skip: Int, withPossiblePrices: Boolean): PlantFeePricesList!
  fees(all: Boolean, category: IdInput, limit: Int, skip: Int, types: [FeeTypeEnum!]): PlantFeesList!
  id: ID!
  image: Resource
  invoiceAddress: String
  name: String!
  openHours: [[Float!]!]
  optionPrices(category: IdInput, groups: [PriceGroupEnum!]): [OptionPrice!]!
  optionPricesP(category: IdInput, groups: [PriceGroupEnum!], limit: Int, skip: Int): OptionPricePaginatedList!
  options(all: Boolean, category: IdInput, group: String, id: ID, limit: Int, skip: Int): PlantOptionList!
  phone: String
  pickup(category: IdInput): Boolean
  prettyIdPrefix: String
  productCategories: [ProductCategory!]!
  productDecoratePrices(category: IdInput, groups: [PriceGroupEnum!]): [ProductDecoratePrice!]!
  productDecoratePricesP(category: IdInput, groups: [PriceGroupEnum!], limit: Int, skip: Int): ProductDecoratePricePaginatedList!
  productDecorates(all: Boolean, category: IdInput, group: String, limit: Int, search: String, skip: Int): PlantProductDecorateList!
  productTypePrices(category: IdInput, groups: [PriceGroupEnum!]): [ProductTypePrice!]!
  productTypePricesP(category: IdInput, groups: [PriceGroupEnum!], limit: Int, skip: Int): ProductTypePricePaginatedList!
  productTypes(all: Boolean, category: IdInput, enabledForFee: IdInput, group: String, limit: Int, notEnabledForFee: IdInput, search: String, skip: Int): PlantProductTypeList!
  serviceName: String!
  settings: PlantSettings!
  supplier: Supplier!
  timezone: String!
}

type PlantByCategory {
  category: ProductCategory!
  count: Int!
}

type PlantCluster {
  count: Int!
  countByCategory: [PlantClusterByCategory!]!
  countBySupplier: [PlantClusterBySupplier!]!
  id: ID!
  location: Location!
  value: Plant
  values: [PlantClusterValue!]!
}

type PlantClusterByCategory {
  category: ProductCategory!
  count: Int!
}

type PlantClusterBySupplier {
  count: Int!
  supplier: Supplier!
}

type PlantClusterValue {
  id: ID!
  location: Location!
  name: String!
}

type PlantConfigInstance {
  deliveryMethod: DeliveryMethod!
  id: ID!
  pickup: Boolean!
  plant: Plant!
  product: ProductCategory!
  selfPickup: Boolean!
}

type PlantCountByGroup {
  count: Int!
  group: String
}

"Autogenerated return type of PlantCreate"
type PlantCreatePayload {
  plant: Plant
  success: Boolean!
}

type PlantCustomField {
  name: String!
  value: String!
}

type PlantDeliveryMethod {
  category: ProductCategory!
  deliveryMethod: DeliveryMethod!
}

type PlantDeliveryMethodList {
  count: Int!
  values: [PlantDeliveryMethod!]!
}

"Autogenerated return type of PlantDeliveryMethodRemove"
type PlantDeliveryMethodRemovePayload {
  success: Boolean!
}

type PlantDiscount {
  amount: Float!
  discount: Float!
  product: ProductCategory!
}

type PlantFeePricesList {
  count: Int!
  values: [FeePrice!]!
}

type PlantFeesInstance {
  active: Boolean!
  fee: Fee!
}

type PlantFeesList {
  count: Int!
  values: [PlantFeesInstance!]!
}

type PlantInventoryList {
  plant: Plant!
  quantity: Int
}

type PlantList {
  clusters(precision: Float!): [PlantCluster!]!
  count: Int!
  countByCategory: [PlantByCategory!]!
  navigation(plant: IdInput!): PlantNavigation
  values: [Plant!]!
}

type PlantNavigation {
  next: Plant
  position: Int
  prev: Plant
}

type PlantOptionInstance {
  active: Boolean!
  option: Option!
}

type PlantOptionList {
  count: Int!
  countByGroup: [PlantCountByGroup!]!
  groups: [String!]!
  values: [PlantOptionInstance!]!
}

"Autogenerated return type of PlantProductCreate"
type PlantProductCreatePayload {
  success: Boolean!
}

type PlantProductDecorate {
  active: Boolean!
  productDecorate: ProductDecorate!
}

type PlantProductDecorateList {
  count: Int!
  countByGroup: [PlantCountByGroup!]!
  groups: [String!]!
  values: [PlantProductDecorate!]!
}

"Autogenerated return type of PlantProductDelete"
type PlantProductDeletePayload {
  success: Boolean!
}

type PlantProductList {
  count: Int!
  values: [ProductCategory!]!
}

type PlantProductType {
  active: Boolean!
  productType: ProductType!
}

type PlantProductTypeList {
  count: Int!
  countByGroup: [PlantCountByGroup!]!
  groups: [String!]!
  values: [PlantProductType!]!
}

"Autogenerated return type of PlantProductUpdate"
type PlantProductUpdatePayload {
  success: Boolean!
}

"Autogenerated return type of PlantRemove"
type PlantRemovePayload {
  success: Boolean!
}

type PlantSettings {
  availabilityTimes(category: IdInput): [PlantSettingsAvailabilityTimes!]!
  booking(category: IdInput): [PlantSettingsBooking!]!
  quantities(category: IdInput): [PlantSettingsQuantities!]!
  termsAndConditions(category: IdInput): [PlantSettingsTermsAndConditions!]!
}

type PlantSettingsAvailabilityTimes {
  category: ProductCategory
  deliveryWindow: Int!
  possibleDeliveryWindows: [Int!]!
  possibleSteps: [Int!]!
  step: Int!
  values: [[Int!]!]!
  workingHoursLimits: [Int!]!
}

type PlantSettingsBooking {
  cancelingFeePrice: Price
  category: ProductCategory
  holdingFeePrice: Price
  lockToCancelTime: Int!
  lockToHoldTime: Int!
  lockToModifyTime: Int!
  maxCountToHold: Int!
  pickup: Boolean
}

type PlantSettingsQuantities {
  balanceTruck: Float
  category: ProductCategory
  deliveryMethod: DeliveryMethod
  maxTrucksQuantity: Float
  minOrderAmount: Float
  minOrderQuantity: Float
  minTruckCapacity: Float
  secondaryMinTruckCapacity: Float
  secondaryStep: Float
  secondaryTruckCapacity: Float
  secondaryUnits: String
  step: Float
  truckCapacity: Float
  units: String
}

type PlantSettingsTermsAndConditions {
  additionalCharges: String!
  category: ProductCategory
  contractorRequirements: String!
  deliveryDisclaimers: String!
  note: String!
  policy: String!
}

"Autogenerated return type of PlantUpdateOptions"
type PlantUpdateOptionsPayload {
  options: [PlantOptionInstance!]!
  success: Boolean!
}

"Autogenerated return type of PlantUpdate"
type PlantUpdatePayload {
  plant: Plant
  success: Boolean!
}

"Autogenerated return type of PlantUpdateProductDecorates"
type PlantUpdateProductDecoratesPayload {
  productDecorates: [PlantProductDecorate!]!
  success: Boolean!
}

"Autogenerated return type of PlantUpdateProductTypes"
type PlantUpdateProductTypesPayload {
  productTypes: [PlantProductType!]!
  success: Boolean!
}

type Price {
  content: String!
  currency: String!
  exchangeRate: Float!
  formula: Formula
  formulaArguments: JSON
  id: ID
  originalValue: Float!
  priority: Int!
  value: Float!
}

type ProductCategory {
  active: Boolean!
  "[DEPRECATED]"
  details: ProductDetails!
  exportCode: String
  id: ID!
  image: String
  industry: String!
  industryColor: String!
  name: String!
  permissions: ProductCategoryPermissions!
  root: ProductCategory
  serviceName: String!
  sortOrder: Int!
  usage(supplier: IdInput): ProductCategoryUsage!
}

"Autogenerated return type of ProductCategoryBatchUpdate"
type ProductCategoryBatchUpdatePayload {
  productCategories: [ProductCategory!]!
  success: Boolean!
}

"Autogenerated return type of ProductCategoryCreate"
type ProductCategoryCreatePayload {
  productCategory: ProductCategory
  success: Boolean!
}

"Autogenerated return type of ProductCategoryDelete"
type ProductCategoryDeletePayload {
  success: Boolean!
}

type ProductCategoryList {
  count: Int!
  values: [ProductCategory!]!
}

type ProductCategoryPermissions {
  decorates: Boolean!
  deliveryFees: Boolean!
  deliveryMethods: Boolean!
  fullEdit: Boolean!
  options: Boolean!
  productColors: Boolean!
  productModifications: Boolean!
  seasonalFees: Boolean!
  service: JSON
  trucks: Boolean!
  underloadFees: Boolean!
  washoutFees: Boolean!
}

"Autogenerated return type of ProductCategoryUpdate"
type ProductCategoryUpdatePayload {
  productCategory: ProductCategory
  success: Boolean!
}

type ProductCategoryUsage {
  plants: [Plant!]!
}

type ProductDecorate {
  active: Boolean!
  category: ProductCategory
  color: String
  "[DEPRECATED]"
  details: ProductDecorateDetails!
  exportCode: String
  id: ID!
  image: String
  name: String!
  root: ProductType
  serviceName: String!
  sortOrder: Int!
  taxable: Boolean!
}

"Autogenerated return type of ProductDecorateBatchUpdate"
type ProductDecorateBatchUpdatePayload {
  productDecorates: [ProductDecorate!]!
  success: Boolean!
}

"Autogenerated return type of ProductDecorateCreate"
type ProductDecorateCreatePayload {
  productDecorate: ProductDecorate
  success: Boolean!
}

type ProductDecorateDetails {
  color: String
  image: String
}

type ProductDecorateList {
  count: Int!
  values: [ProductDecorate!]!
}

type ProductDecoratePrice {
  city: City
  group: String
  id: ID!
  plant: Plant
  price: Price!
  productDecorate: ProductDecorate!
  productType: ProductType
  supplier: Supplier
}

"Autogenerated return type of ProductDecoratePriceCreate"
type ProductDecoratePriceCreatePayload {
  productDecoratePrice: ProductDecoratePrice
  success: Boolean!
}

type ProductDecoratePriceList {
  count: Int!
  values: [ProductDecoratePrice!]!
}

type ProductDecoratePricePaginatedInstance {
  prices: [ProductDecoratePrice!]!
  productDecorate: ProductDecorate!
}

type ProductDecoratePricePaginatedList {
  count: Int!
  groups: [String!]!
  values: [ProductDecoratePricePaginatedInstance!]!
}

"Autogenerated return type of ProductDecoratePriceUpdate"
type ProductDecoratePriceUpdatePayload {
  productDecoratePrice: ProductDecoratePrice
  success: Boolean!
}

"Autogenerated return type of ProductDecorateUpdate"
type ProductDecorateUpdatePayload {
  productDecorate: ProductDecorate
  success: Boolean!
}

"Autogenerated return type of ProductDependenciesRemove"
type ProductDependenciesRemovePayload {
  success: Boolean!
}

type ProductDependencyInstance {
  orders: [Order!]!
  plants: [Plant!]!
  productDecoratePrices: [ProductDecoratePrice!]!
  productTypePrices: [ProductTypePrice!]!
}

type ProductDetails {
  image: String
  serviceKey: String!
  units: String!
}

"Product Type object. Contains information about product and his modifications"
type ProductType {
  "Flag to show visible status, for dashboard"
  active: Boolean!
  additional: JSON!
  "Category"
  category: ProductCategory
  characteristics: [[String!]!]!
  colors: [ProductDecorate!]
  combinations: [ProductTypeCombinationInstance!]
  custom: Boolean!
  "Description test in MD-style"
  description: String
  "The list of images urls for this product"
  descriptionImages: [String!]
  "The list of files urls for this product"
  descriptionResources: [ProductTypeImageResource!]
  "[DEPRECATED]"
  details: ProductTypeDetails!
  "External ID, used in integrations with third part systems. For dashboard"
  exportCode: String!
  "The hash of filter values for the current product. Uses for filter panel."
  filter: JSON!
  "Group name (subcategory)"
  group: String
  id: ID!
  "Link to main image"
  image: String
  "Shows how should be measured this product type. Can be primary or secondary"
  measuredAs: String!
  modifications: [ProductTypeModificationInstance!]!
  "Display name"
  name: String!
  "[DEPRECATED]"
  optionCombinations: [ProductTypeOptionValue!]
  "[DEPRECATED]"
  options: ProductTypeOptions
  "Link to the parent product.Not null only if the current product is modification of the parent one. "
  parent: ProductType
  permissions: ProductTypePermissions!
  possibleColors: [ProductDecorate!]
  "[DEPRECATED]"
  possibleOptionsValues: [ProductTypeOptionValue!]
  "[DEPRECATED]"
  root: ProductType
  "Internal (service) name, for dashboard"
  serviceName: String!
  "Short description text"
  shortDescription: String
  "Sort order, for dashboard"
  sortOrder: Int!
  "The link to specification file(pdf)"
  specification: String
  "The list of tags assigned to product. For Dashboard"
  tags: [String!]
  taxable: Boolean!
  "[DEPRECATED]"
  virtualPrice: ProductTypeVirtualPriceSimple
}

"Autogenerated return type of ProductTypeBatchUpdate"
type ProductTypeBatchUpdatePayload {
  productTypes: [ProductType!]!
  success: Boolean!
}

type ProductTypeCombinationInstance {
  description: String
  id: ID!
  modifications: [ProductTypeModificationInstance!]
  value: String!
}

"Autogenerated return type of ProductTypeCreateCustom"
type ProductTypeCreateCustomPayload {
  productTypePrice: OrderPreparatoryConfigProductTypePrice
  success: Boolean!
}

"Autogenerated return type of ProductTypeCreate"
type ProductTypeCreatePayload {
  productType: ProductType
  success: Boolean!
}

type ProductTypeDetails {
  description: JSON
  group: String
  image: String
  specification: JSON
}

type ProductTypeImageResource {
  description: String
  id: ID!
  sortOrder: Int
  url: String!
}

type ProductTypeLike {
  contractor: Contractor
  createdAt: String!
  id: ID!
  productType: ProductType!
}

"Autogenerated return type of ProductTypeLike"
type ProductTypeLikePayload {
  favoriteProductTypes: [ProductTypeLike!]!
  success: Boolean!
}

type ProductTypeList {
  count: Int!
  groups: [String!]!
  values: [ProductType!]!
}

type ProductTypeModificationInstance {
  characteristics: [[String!]!]!
  color: String
  description: String
  id: ID!
  image: String
  imageCaption: String
  imageFullscreen: Boolean!
  label: String!
  name: String!
  numeric: Int
  sortOrder: Int!
  type: String!
}

type ProductTypeOptionValue {
  description: String
  id: ID!
  modifications: [ProductTypeModificationInstance!]
  value: String!
}

type ProductTypeOptions {
  label: String!
  values: [ProductTypeOptionValue!]!
}

type ProductTypePermissions {
  colors: Boolean!
  fullEdit: Boolean!
  modifications: Boolean!
}

type ProductTypePrice {
  city: City
  group: String
  id: ID!
  partner: Partner
  plant: Plant
  price: Price!
  productType: ProductType!
  supplier: Supplier
}

"Autogenerated return type of ProductTypePriceCreate"
type ProductTypePriceCreatePayload {
  productTypePrice: ProductTypePrice
  success: Boolean!
}

"Autogenerated return type of ProductTypePriceDelete"
type ProductTypePriceDeletePayload {
  success: Boolean!
}

type ProductTypePriceList {
  count: Int!
  values: [ProductTypePrice!]!
}

type ProductTypePricePaginatedInstance {
  prices: [ProductTypePrice!]!
  productType: ProductType!
}

type ProductTypePricePaginatedList {
  count: Int!
  groups: [String!]!
  values: [ProductTypePricePaginatedInstance!]!
}

"Autogenerated return type of ProductTypePriceUpdate"
type ProductTypePriceUpdatePayload {
  productTypePrice: ProductTypePrice
  success: Boolean!
}

"Autogenerated return type of ProductTypeUnlike"
type ProductTypeUnlikePayload {
  success: Boolean!
}

"Autogenerated return type of ProductTypeUpdate"
type ProductTypeUpdatePayload {
  productType: ProductType
  success: Boolean!
}

type ProductTypeVirtualPrice {
  coverage: Float
  unit: String
  value: Float
}

type ProductTypeVirtualPriceSimple {
  unit: String
  value: String
}

type Project {
  additionalInfo: String
  address: Address
  availableActions: [String!]!
  clientEmail: String
  clientName: String
  clientPhone: String
  completedAt: String
  contractor: Contractor
  createdAt: String!
  daysToStart: Int!
  estimatedValue: Float
  exportCode: String
  feePrices(category: IdInput, limit: Int, skip: Int): ProjectFeePrices!
  id: ID!
  images: [ProjectImage!]!
  kind: String
  name: String!
  notes: [String!]!
  number: ID!
  optionPrices(category: IdInput, limit: Int, skip: Int): ProjectOptionPrices!
  orders: [Order!]!
  ordersP(limit: Int, skip: Int, status: [OrderStatusEnum!]): OrderList!
  plant: Plant
  possibleCategories: [ProductCategory!]!
  possibleFees(category: IdInput): [Fee!]!
  possibleOptions(category: IdInput): [Option!]!
  possibleProductTypes(category: IdInput): [ProductType!]!
  prettyId: String!
  priceGroups(limit: Int, plants: [IdInput!], products: [IdInput!], skip: Int): ProjectPriceGroupList!
  priceLocked: Boolean!
  productTypePrices(category: IdInput, limit: Int, skip: Int): ProjectProductTypePrices!
  quoteStatus: String!
  resources(limit: Int, skip: Int, types: [ProjectResourceTypeEnum!]): ProjectResourceList!
  route: Route
  spent: Float!
  startedAt: String
  status(combined: Boolean): String!
  taxable: Boolean!
  taxableApproved: Boolean!
  timezone: String!
  type: String
  updatedAt: String
  workType: String
}

"Autogenerated return type of ProjectComplete"
type ProjectCompletePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  project: Project!
  success: Boolean!
}

"Autogenerated return type of ProjectCreate"
type ProjectCreatePayload {
  project: Project
  success: Boolean!
}

type ProjectFeePrices {
  categories: [ProductCategory!]!
  count: Int!
  values: [FeePrice!]!
}

type ProjectImage {
  createdAt: String!
  id: ID!
  image: Resource!
  type: String
}

"Autogenerated return type of ProjectImageAdd"
type ProjectImageAddPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  images: [ProjectImage!]
  success: Boolean!
}

"Autogenerated return type of ProjectImageRemove"
type ProjectImageRemovePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

type ProjectList {
  count: Int!
  values: [Project!]!
}

"Autogenerated return type of ProjectNoteAdd"
type ProjectNoteAddPayload {
  success: Boolean!
}

"Autogenerated return type of ProjectNoteRemove"
type ProjectNoteRemovePayload {
  success: Boolean!
}

"Autogenerated return type of ProjectNoteUpdate"
type ProjectNoteUpdatePayload {
  success: Boolean!
}

type ProjectOptionPrices {
  categories: [ProductCategory!]!
  count: Int!
  values: [OptionPrice!]!
}

type ProjectPriceGroupInstance {
  group: String!
  plant: Plant
  priority: Int!
  product: ProductCategory
}

type ProjectPriceGroupList {
  count: Int!
  values: [ProjectPriceGroupInstance!]!
}

"Autogenerated return type of ProjectPricesUpdate"
type ProjectPricesUpdatePayload {
  project: Project
  success: Boolean!
}

type ProjectProductTypePrices {
  categories: [ProductCategory!]!
  count: Int!
  values: [ProductTypePrice!]!
}

"Autogenerated return type of ProjectQuoteAccept"
type ProjectQuoteAcceptPayload {
  project: Project!
  success: Boolean!
}

"Autogenerated return type of ProjectQuoteRequest"
type ProjectQuoteRequestPayload {
  project: Project!
  success: Boolean!
}

"Autogenerated return type of ProjectRemove"
type ProjectRemovePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

type ProjectResource {
  createdAt: String!
  id: ID!
  resource: Resource!
  type: String
}

"Autogenerated return type of ProjectResourceAdd"
type ProjectResourceAddPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  resources: [ProjectResource!]
  success: Boolean!
}

type ProjectResourceList {
  count: Int!
  values: [ProjectResource!]!
}

"Autogenerated return type of ProjectResourceRemove"
type ProjectResourceRemovePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  success: Boolean!
}

"Autogenerated return type of ProjectStart"
type ProjectStartPayload {
  contractor: Contractor
  contractorMember: ContractorMember
  project: Project!
  success: Boolean!
}

"Autogenerated return type of ProjectUpdate"
type ProjectUpdatePayload {
  contractor: Contractor
  contractorMember: ContractorMember
  project: Project
  success: Boolean!
}

"Autogenerated return type of ProjectUpdatePriceGroups"
type ProjectUpdatePriceGroupsPayload {
  success: Boolean!
}

type QuantitiesConfig {
  min: Float!
  secondaryMin: Float
  secondaryStep: Float
  secondaryUnits: String
  step: Float!
  units: String!
  virtualCoverage: Float
  virtualStep: Float
  virtualUnits: String
}

type Query {
  _jobsMeta: _QueryMeta!
  availabilityBlockOffs(city: [IdInput!], from: String, limit: Int, plant: [IdInput!], product: [IdInput!], skip: Int, to: String): AvailabilityTimeBlockOffList!
  cart(id: ID): Cart!
  cartPreparatoryConfig(cart: IdInput): CartPreparatoryConfig!
  channelMessages(channels: [IdInput!]!, from: String, unreadOnly: Boolean): [ChannelMessageList!]!
  channels(all: Boolean, contractors: [IdInput!], drivers: [IdInput!], limit: Int, orders: [IdInput!], partners: [IdInput!], projects: [IdInput!], search: String, skip: Int, unreadOnly: Boolean): ChannelList!
  cities(all: Boolean, limit: Int, partner: IdInput, point: LocationInput, search: String, skip: Int): [City!]!
  clientConfig: PartnerClientConfigList!
  config: Config!
  contractor(id: ID): Contractor
  contractorSkids(all: Boolean, contractor: IdInput, limit: Int, search: String, skid: IdInput, skip: Int): ContractorSkidList
  contractors(ignoreScope: Boolean, limit: Int, search: String, skip: Int): ContractorList!
  countries(limit: Int, skip: Int): [Country!]!
  countryStates(limit: Int, search: String, skip: Int): CountryStateList!
  dashboard: Dashboard!
  deliveryMethods(limit: Int, skip: Int): DeliveryMethodList!
  driver(id: ID!): Driver!
  driverBlockOff(id: ID!): DriverBlockOff!
  driverOrders(driver: IdInput, from: String, limit: Int, search: String, skip: Int, sortOrder: SortDirectionEnum, statuses: [DriverTruckStatusEnum!], to: String, updatedAtFrom: String): OrderTruckList!
  drivers(city: IdInput, limit: Int, orderTruck: IdInput, plant: IdInput, search: String, skip: Int): DriverList!
  exportContractors(async: Boolean, contractors: [IdInput!]!): ExportResult!
  exportOrders(async: Boolean, exportAction: String!, orders: [IdInput!]!): ExportResult!
  exportTransactions(async: Boolean, exportAction: String!, transactions: [IdInput!]!): ExportResult!
  exportWorkingDays(async: Boolean, dayFrom: String!, dayTo: String!, exportAction: String!): ExportResult!
  favoriteProductTypes(contractor: IdInput, limit: Int, partner: IdInput, skip: Int): FavoriteProductTypes!
  fees(limit: Int, skip: Int, type: [FeeTypeEnum!]): FeeList!
  finances(contractor: IdInput, creditStatuses: [CreditStatusEnum!], dateFrom: String, dateTo: String, exported: Boolean, filter: String, invoiced: Boolean, limit: Int, offline: Boolean, paid: Boolean, partner: IdInput, paymentStatus: [OrderPaymentStatusEnum!], skip: Int, status: FinanceStatusEnum, statuses: [FinanceStatusEnum!]): PartnerFinanceList!
  financesExport(finances: [IdInput!]!): CsvExport!
  financesStats(from: String, partner: IdInput, period: FinancePeriodEnum, to: String): PartnerAccountStatsInstance!
  formulas(limit: Int, skip: Int): FormulaList!
  gallery(orders: [IdInput!]): GalleryList!
  globalMap(city: [IdInput!], contractor: IdInput, driver: [IdInput!], from: String, limit: Int, plant: [IdInput!], precision: Float!, product: [IdInput!], project: [IdInput!], region: RegionInput, search: String, skip: Int, skipPremiumPartners: Boolean, status: [OrderStatusEnum!], supplier: [IdInput!], to: String, withTest: Boolean): GlobalMapList!
  inventories(limit: Int, plants: [IdInput!], skip: Int): InventoryList!
  invite(id: ID!): Invite!
  jobDetails(id: ID!): CareerJob
  jobStatus(jobs: [String!]!): JobStatusList!
  jobs(limit: Int, skip: Int): CareerJobList!
  me: MeInfo!
  option(id: ID!, supplier: IdInput): Option!
  options(category: IdInput, limit: Int, root: Boolean, skip: Int, supplier: IdInput): OptionList!
  order(id: ID, token: String): Order!
  orderMessages(from: String, orders: [IdInput!]!, unreadOnly: Boolean): [OrderMessageList!]!
  orderPreparatoryConfig(contractor: IdInput, input: OrderPreparatoryConfigInput, order: IdInput, partner: IdInput): OrderPreparatoryConfig!
  orderTruck(id: ID!, limit: Int, skip: Int): OrderTruck!
  orderTrucks(
    cities: [IdInput!],
    drivers: [IdInput!],
    from: String,
    limit: Int,
    orders: [IdInput!],
    search: String,
    skip: Int,
    sortOrder: SortDirectionEnum,
    statuses: [DriverTruckStatusEnum!],
    to: String,
    trucks: [IdInput!],
    updatedAtFrom: String,
    "Filter by: was driver assigned on truck or no"
    withDriver: Boolean,
    "Filter by: test orders"
    withTest: Boolean,
    "Filter by: truck presence"
    withTruck: Boolean
  ): OrderTruckList!
  orders(city: [IdInput!], contractor: IdInput, driver: [IdInput!], from: String, limit: Int, paymentStatus: [OrderPaymentStatusEnum!], payoutStatus: FinanceStatusEnum, plant: [IdInput!], product: [IdInput!], project: [IdInput!], region: RegionInput, search: String, skip: Int, skipPremiumPartners: Boolean, sortOrder: SortDirectionEnum, status: [OrderStatusEnum!], supplier: [IdInput!], to: String, updatedAtFrom: String, withTest: Boolean): OrderListExtended!
  ordersChanges(before: String, city: [IdInput!], lastCreatedAt: String, limit: Int, orders: [IdInput!], plant: [IdInput!], product: [IdInput!], region: RegionInput, search: String, skip: Int, sortOrder: SortDirectionEnum, supplier: [IdInput!], withArchived: Boolean, withTest: Boolean): OrderChanges!
  partner(code: String, id: ID): Partner
  partnerContractors(accountStatus: [PartnerContractorAccountStatusEnum!], contractors: [IdInput!], from: String, limit: Int, markAsRead: Boolean, onlyNotRead: Boolean, partners: [IdInput!], priceStatus: [PartnerContractorPriceStatusEnum!], search: String, skip: Int, source: [PartnerContractorSourceEnum!], status: [PartnerContractorStatusEnum!], to: String): PartnerContractorList
  partnerDrivers(cities: [IdInput!], limit: Int, plants: [IdInput!], search: String, skip: Int, source: [PartnerDriverSourceEnum!], status: [PartnerDriverStatusEnum!]): PartnerDriverList
  partnerPayouts(dateFrom: String, dateTo: String, limit: Int, partner: IdInput, search: String, skip: Int, statuses: [PayoutStatusEnum!]): PartnerPayoutList!
  partners(category: [IdInput!], limit: Int, paidOnly: Boolean, region: RegionInput, savedOnly: Boolean, search: String, skip: Int, visibleOnly: Boolean): PartnerList
  paymentLink(id: ID!): PaymentLink!
  paymentLinks(contractor: IdInput, from: String, limit: Int, partner: IdInput, search: String, skip: Int, sort: SortDirectionEnum, statuses: [PaymentLinkStatusEnum!], to: String): PaymentLinkList!
  payoutsExport(payouts: [IdInput!]!): CsvExport!
  plant(id: ID!): Plant!
  plantProducts(limit: Int, plant: IdInput!, skip: Int): PlantProductList!
  plants(category: [IdInput!], city: [IdInput!], limit: Int, name: String, partner: IdInput, region: RegionInput, skip: Int, supplier: [IdInput!]): PlantList!
  productCategories(city: IdInput, limit: Int, partner: IdInput, plant: IdInput, region: RegionInput, root: Boolean, search: String, skip: Int, supplier: IdInput): ProductCategoryList!
  productCategory(id: ID!, partner: IdInput, supplier: IdInput): ProductCategory!
  productDecorate(id: ID!, supplier: IdInput): ProductDecorate!
  productDecoratePrices(cities: [IdInput!], groups: [PriceGroupEnum!], limit: Int, plants: [IdInput!], productDecorates: [IdInput!], skip: Int, suppliers: [IdInput!]): ProductDecoratePriceList!
  productDecorates(category: IdInput, limit: Int, root: Boolean, skip: Int, supplier: IdInput): ProductDecorateList!
  productDependencies(category: IdInput!): ProductDependencyInstance!
  productType(id: ID!, partner: IdInput, supplier: IdInput): ProductType!
  productTypePrices(cities: [IdInput!], groups: [PriceGroupEnum!], limit: Int, plants: [IdInput!], productTypes: [IdInput!], skip: Int, suppliers: [IdInput!]): ProductTypePriceList!
  productTypes(city: IdInput, limit: Int, partner: IdInput, plant: IdInput, product: IdInput, root: Boolean, search: String, skip: Int, supplier: IdInput): ProductTypeList!
  project(id: ID!): Project!
  projects(contractor: IdInput, limit: Int, plant: [IdInput!], quoteStatus: [ProjectQuoteEnum!], search: String, skip: Int, status: [ProjectTypeEnum!]): ProjectList!
  questionary(reason: QuestionaryReasonEnum!, targetInput: QuestionaryTargetInput): Questionary
  roles(limit: Int, skip: Int): RoleList!
  skidTransactions(contractor: IdInput, from: String, limit: Int, search: String, skid: IdInput, skip: Int, statuses: [SkidTransactionStatusEnum!], to: String): SkidTransactionList
  skids(limit: Int, search: String, skip: Int): SkidList
  storefront(address: AddressInput, location: IdInput, project: IdInput): Storefront!
  supplier(id: ID!): Supplier
  suppliers(city: IdInput, ignoreScope: Boolean, limit: Int, partner: IdInput, region: RegionInput, search: String, skip: Int): SupplierList
  taxableSettings(contractor: IdInput, countryState: IdInput, project: IdInput, search: String): TaxableSettingsList!
  taxes(countryState: IdInput, search: String): PartnerTaxList!
  transactions(contractor: IdInput, exported: Boolean, from: String, limit: Int, partner: IdInput, search: String, skip: Int, sort: SortDirectionEnum, sources: [TransactionSourceEnum!], statuses: [TransactionStatusEnum!], to: String): TransactionList!
  truck(id: ID!): Truck!
  trucks(city: IdInput, driver: IdInput, limit: Int, plant: IdInput, search: String, skip: Int): TruckList!
  widget(id: ID!): WidgetInstance
  widgets(designs: [WidgetDesignEnum!], limit: Int, modes: [WidgetModeEnum!], partners: [IdInput!], search: String, skip: Int, types: [WidgetTypeEnum!]): WidgetList!
}

type Questionary {
  createdAt: String!
  id: ID!
  name: String!
  reason: QuestionaryReasonEnum!
  template: JSON
  updatedAt: String
}

"Autogenerated return type of QuestionaryAnswerSave"
type QuestionaryAnswerSavePayload {
  success: Boolean!
}

type Resource {
  "[DEPRECATED]"
  fileUrl: String
  id: ID
  mimeType: String
  "[DEPRECATED]"
  source: String
  url: String
}

type Role {
  createdAt: String!
  id: ID!
  name: String!
  partner: Partner
  updatedAt: String!
}

type RoleList {
  count: Int!
  values: [Role!]!
}

type Route {
  distance: Float!
  distanceUnit: String
  duration: Float!
  routes: [JSON!]!
}

"Autogenerated return type of ServiceRequestInfo"
type ServiceRequestInfoPayload {
  success: Boolean!
}

type Skid {
  createdAt: String!
  id: ID!
  name: String!
  partner: Partner!
  updatedAt: String!
}

type SkidContractorListInstance {
  contractor: Contractor
  quantity: Int
  skid: Skid
}

type SkidList {
  count: Int!
  values: [Skid!]!
}

type SkidTransaction {
  availableActions: [String!]!
  contractor: Contractor!
  createdAt: String!
  id: ID!
  order: Order!
  quantity: Int!
  reason: String!
  skid: Skid!
  status: String!
  type: String!
  updatedAt: String!
}

"Autogenerated return type of SkidTransactionDelete"
type SkidTransactionDeletePayload {
  success: Boolean!
}

type SkidTransactionList {
  count: Int!
  values: [SkidTransaction!]!
}

type SourceInfo {
  name: String
  platform: String
}

type Storefront {
  locations(limit: Int, region: RegionInput, skip: Int): PlantList!
  productTypes(categories: [IdInput!], favorite: Boolean, filters: JSON, limit: Int, mainPage: Boolean, search: String, skip: Int, skipCurrentLocation: Boolean): StorefrontProductTypeList!
}

type StorefrontProductTypeList {
  availableFilters: Json
  count: Count!
  values: [OrderPreparatoryConfigProductTypePrice!]!
}

type SubscriptionInstance {
  expiresAt: String
  type: String
}

type SuperAdmin {
  email: String!
  id: ID!
}

type Supplier {
  categories: ProductCategoryList!
  id: ID!
  members(limit: Int, skip: Int): SupplierMemberList!
  name: String!
  partners: [Partner!]!
  plants(limit: Int, skip: Int): PlantList!
  productTypes: ProductTypeList!
}

"Autogenerated return type of SupplierCreate"
type SupplierCreatePayload {
  success: Boolean!
  supplier: Supplier
}

type SupplierList {
  count: Int!
  values: [Supplier!]!
}

type SupplierMember {
  active: Boolean!
  avatar: String
  email: String
  id: ID!
  identities: [Identity!]!
  identity: Identity
  name: String!
  role: String!
  supplier: Supplier!
}

"Autogenerated return type of SupplierMemberCreate"
type SupplierMemberCreatePayload {
  member: SupplierMember!
  success: Boolean!
}

type SupplierMemberList {
  count: Int!
  values: [SupplierMember!]!
}

"Autogenerated return type of SupplierMemberRemove"
type SupplierMemberRemovePayload {
  success: Boolean!
}

"Autogenerated return type of SupplierMemberResetPassword"
type SupplierMemberResetPasswordPayload {
  success: Boolean!
}

"Autogenerated return type of SupplierMemberUpdate"
type SupplierMemberUpdatePayload {
  member: SupplierMember!
  success: Boolean!
}

"Autogenerated return type of SupplierUpdate"
type SupplierUpdatePayload {
  success: Boolean!
  supplier: Supplier
}

type TaxableSettings {
  contractor: Contractor
  fee: Fee!
  id: ID!
  project: Project
  zeroOut: Boolean!
}

type TaxableSettingsList {
  count: Int!
  taxes: PartnerTaxList!
  values: [TaxableSettings!]!
}

type Transaction {
  amount: Float!
  availableActions: [String!]!
  contractor: Contractor
  createdAt: String!
  currency: String!
  description: String
  exported: Boolean
  id: ID!
  offlineType: TransactionOfflineTypeEnum
  paymentMethod: PaymentMethod
  payout: PartnerPayoutInstance
  payoutAmount: Float
  payoutFee: Float
  prettyId: String!
  processingAmount: Float
  processingFee: Fee
  provider: String!
  reason: TransactionReason!
  referenceNumber: String
  status: String!
  statusChangedAt: String
  stripeSource: JSON
  stripeStatus: String
  stripeUrl: String
  type: String!
}

type TransactionList {
  count: Int!
  values: [Transaction!]!
}

type TransactionReason {
  order: Order
  paymentIntent: PaymentIntent
  paymentLink: PaymentLink
  type: String!
}

"Autogenerated return type of TransactionSetExported"
type TransactionSetExportedPayload {
  success: Boolean!
  transaction: Transaction
  transactions: [Transaction!]
}

type Truck {
  blockOff(date: String!): Boolean
  deviceId: String
  driver: Driver
  id: ID!
  location: Location
  name: String!
  note: Note
  notes(limit: Int, skip: Int): NoteList
  plants: [Plant!]!
  productCategories: [ProductCategory!]
  type: String!
  updatedAt: String!
}

"Autogenerated return type of TruckAccept"
type TruckAcceptPayload {
  success: Boolean!
  truck: Truck
}

"Autogenerated return type of TruckArrive"
type TruckArrivePayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of TruckCancel"
type TruckCancelPayload {
  success: Boolean!
  truck: Truck
}

"Autogenerated return type of TruckComplete"
type TruckCompletePayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of TruckCreate"
type TruckCreatePayload {
  success: Boolean!
  truck: Truck
}

type TruckList {
  count: Int!
  values: [Truck!]!
}

"Autogenerated return type of TruckNoteUpdate"
type TruckNoteUpdatePayload {
  note: Note
  success: Boolean!
}

"Autogenerated return type of TruckRemove"
type TruckRemovePayload {
  success: Boolean!
}

"Autogenerated return type of TruckReturn"
type TruckReturnPayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of TruckRevert"
type TruckRevertPayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of TruckStart"
type TruckStartPayload {
  success: Boolean!
  truck: OrderTruck
}

"Autogenerated return type of TruckUpdate"
type TruckUpdatePayload {
  success: Boolean!
  truck: Truck
}

type TrucksConfig {
  balanceTruck: Float
  count: TrucksConfigCountType!
  deliveryMethod: DeliveryMethod!
  order: TrucksConfigOrderType!
  quantity: TrucksConfigQuantityType!
  secondaryQuantity: TrucksConfigSecondaryQuantityType
}

type TrucksConfigCountType {
  max: Int!
}

type TrucksConfigOrderType {
  minAmount: Float
  minQuantity: Float
}

type TrucksConfigQuantityType {
  max: Float!
  min: Float!
  step: Float!
}

type TrucksConfigSecondaryQuantityType {
  max: Float!
  min: Float!
  step: Float!
}

type Unit {
  code: String!
  name: String!
  plural: [String!]!
}

type User {
  name: String
  role: String
}

"Autogenerated return type of UserSetClientStore"
type UserSetClientStorePayload {
  success: Boolean!
}

"Autogenerated return type of WidgetCreate"
type WidgetCreatePayload {
  success: Boolean!
  widget: WidgetInstance!
}

"Autogenerated return type of WidgetDelete"
type WidgetDeletePayload {
  success: Boolean!
}

type WidgetInstance {
  align: String
  backgroundColor: String
  createdAt: String!
  description: String
  design: String!
  embedCode: String!
  id: ID!
  image: Boolean
  imageBackground: Boolean
  imageSize: Int
  logo: String
  mode: String!
  partner: Partner!
  shift: Int
  statistics: WidgetStatistics!
  title: String
  titleColor: String
  type: String!
  usePartnerLogo: Boolean
}

type WidgetList {
  count: Int!
  values: [WidgetInstance!]!
}

type WidgetStatistics {
  clicks: Int!
  earned: Float!
  loads: Int!
  orders: Int!
  signups: Int!
}

"Autogenerated return type of WidgetUpdate"
type WidgetUpdatePayload {
  success: Boolean!
  widget: WidgetInstance!
}

type WorkingDay {
  day: String!
  driverRoutes(limit: Int, skip: Int): DriverRouteList!
  finishedAt: String
  id: ID!
  startedAt: String
  status: String!
  timezone: String!
}

type _QueryMeta {
  count: Int!
}

enum CreditStatusEnum {
  normal
  overdue
  very_overdue
}

enum DeliveryItemStatusEnum {
  delivered
  pending
  skipped
}

enum DriverBlockOffEnum {
  pto
  sick_leave
}

enum DriverTruckStatusEnum {
  accepted
  arrived
  delivered
  new
  onsite_job_completed
  onsite_job_started
  returning
  started
}

enum FeePickupEnum {
  default
  excluded
  included
}

enum FeeTypeEnum {
  common
  delivery
  discount
  one_time
  seasonal
  tax
  timeframe
  underload
  washout
}

enum FinancePeriodEnum {
  daily
  monthly
  weekly
}

enum FinanceStatusEnum {
  order_canceled
  order_completed
  order_in_progress
  order_not_paid
  order_on_hold
}

enum IdentityTypeEnum {
  contractor
  driver
  partner
  super_admin
  supplier
}

enum OauthProviderEnum {
  apple
  facebook
  google
  vendasta
}

enum OneTimeCodeEnum {
  canceling
  holding
  internal
  same_day_delivery_change
  waiting_time
  waiting_time_deposit
}

enum OrderChangeGroupEnum {
  address
  delivery_time
  product
  trucks
}

enum OrderPaymentModeEnum {
  default
  offline
  partner_account
}

enum OrderPaymentStatusEnum {
  account
  failed
  none
  paid
  partially_paid
  pending
  waiting_for_payment
}

enum OrderPriceModeEnum {
  account
  default
  without
}

enum OrderResourceTypeEnum {
  after
  before
  during
}

enum OrderStateEnum {
  arrived
  booked
  confirmed
  departed
  returned
}

enum OrderStatusEnum {
  active
  canceled
  delivered
  delivering
  incoming
  live
  on_hold
  quote
}

enum OrderTruckStatusEnum {
  delayed
  early
  late
  on_time
  ready_to_pickup
}

enum PartnerContractorAccountStatusEnum {
  accepted
  none
  request_existed
  request_new
}

enum PartnerContractorBilldStatusEnum {
  accepted
  none
  rejected
  requested
}

enum PartnerContractorPriceStatusEnum {
  done
  none
  pending
}

enum PartnerContractorSourceEnum {
  account_request
  invite
  order
  price_request
  quote_request
  signup
}

enum PartnerContractorStatusEnum {
  accepted
  disabled
  incoming
  rejected
}

enum PartnerDriverSourceEnum {
  invite
  signup
}

enum PartnerDriverStatusEnum {
  accepted
  disabled
  incoming
  rejected
}

enum PaymentLinkStatusEnum {
  canceled
  error
  in_transit
  new
  success
}

enum PaymentMethodProviderEnum {
  eway
  stripe
}

enum PayoutStatusEnum {
  canceled
  failed
  in_transit
  paid
  pending
  processing
  success
}

enum PriceGroupEnum {
  A
  B
  C
  D
  E
  default
}

enum ProjectQuoteEnum {
  added
  none
  requested
}

enum ProjectResourceTypeEnum {
  image
  plans
  quote
  specs
  tax
}

enum ProjectTypeEnum {
  active
  completed
  upcoming
}

enum QuestionaryReasonEnum {
  delivery_control
  new_order
  signup
}

enum QuestionaryTargetNameEnum {
  contractor
  oder
  order_truck
  project
}

enum RejectReasonEnum {
  delivery_time
}

enum SkidTransactionReasonEnum {
  correction
  receive
  return
  write_off
}

enum SkidTransactionStatusEnum {
  in_progress
  success
}

enum SortDirectionEnum {
  asc
  desc
}

enum TransactionOfflineTypeEnum {
  cash
  cheque
  other
  wire
}

enum TransactionSourceEnum {
  account
  billd
  eway
  manual
  offline
  stripe
  stripe_b2b_ca
  stripe_b2b_us
}

enum TransactionStatusEnum {
  canceled
  error
  in_transit
  requires_capture
  success
}

enum WidgetDesignEnum {
  connect
  regular
  saving
  shop
  shop_fullscreen
}

enum WidgetModeEnum {
  main
  signup
  suppliers
}

enum WidgetTypeEnum {
  inline
  popup
  regular
}

"Represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1."
scalar Count

"Represents untyped JSON"
scalar JSON

"Represents untyped JSON"
scalar Json

scalar Upload

input AddressInput {
  city: String
  fixed: Boolean
  geofenceRadius: Float
  location: LocationInput
  state: String
  streetAddress: String
  zip: String
}

input AvailabilityTimeBlockOffCreateInput {
  city: IdInput
  date: String!
  from: Int!
  plant: IdInput
  product: IdInput
  to: Int!
}

input AvailabilityTimeBlockOffUpdateInput {
  city: IdInput
  date: String
  from: Int
  id: ID!
  plant: IdInput
  product: IdInput
  to: Int
}

input CardInfoInput {
  cardholderName: String
  cvv: String!
  expMonth: Int!
  expYear: Int!
  number: String!
  zip: String
}

input CareerCandidateInput {
  email: String!
  fullName: String!
}

input CareerCandidateRequestCreateInput {
  attachment: String!
  message: String
}

input CartGroupUpdate {
  deliveryDetails: String
  deliveryTime: String
  deliveryWindow: Int
}

input CartItemCreate {
  pickupPlant: IdInput
  productTypePrice: IdInput!
  quantity: Float!
}

input CartItemUpdate {
  cleanPickupPlant: Boolean
  pickupPlant: IdInput
  quantity: Float
}

input CartUpdate {
  address: AddressInput
  cleanProject: Boolean
  project: IdInput
}

input CommonMemberUpdateInput {
  avatar: Upload
  clearAvatar: Boolean
  id: ID
  name: String
  roles: [IdInput!]
}

input ContractorIdentityInputData {
  email: IdentityEmailInput
  oauth: IdentityOauth2Input
  phone: IdentityPhoneInput
}

input ContractorMemberUpdateInfo {
  avatar: String
  avatarFile: Upload
  clearAvatar: Boolean
  name: String
}

input ContractorPaymentMethodInput {
  account: IdInput
  paymentMethod: IdInput
  provider: String!
}

input ContractorPriceGroupCreateInput {
  city: IdInput
  group: PriceGroupEnum!
  plant: IdInput
  productType: IdInput
  supplier: IdInput
}

input ContractorSkidUpdateInput {
  quantity: Int
  skid: IdInput!
}

input ContractorSourceInputData {
  priceRequest: Boolean
  referralCode: String
  referralWidget: String
}

input ContractorUpdateCompanyInfoInput {
  address: AddressInput
  clearLogo: Boolean
  logo: String
  logoFile: Upload
  name: String
}

input ContractorUpdateInfoInput {
  accountingEmail: String
  additional: JSON
  avatar: String
  avatarFile: Upload
  clearAvatar: Boolean
  companyAddress: String
  companyName: String
  companySize: String
  contractorType: String
  country: CountryInput
  customField1: String
  customField2: String
  document: String
  exportCode: String
  name: String
  onboarded: Boolean
  type: String
  verified: Boolean
}

input ContractorUpdatePaymentsInfoInput {
  addPaymentCard: [PaymentMethodCardInput!]
  defaultPaymentMethod: ContractorPaymentMethodInput
  removePaymentCard: [IdInput!]
}

input CountryInput {
  code: String
  id: ID
}

input DeliveryMethodCreateInput {
  description: String
  displayName: String
  image: Upload
  name: String!
}

input DeliveryMethodUpdateInput {
  description: String
  displayName: String
  id: ID!
  image: Upload
  name: String
}

input DriverIdentityInputData {
  email: IdentityEmailInput
  phone: IdentityPhoneInput
}

input DriverInfoInput {
  avatar: String
  avatarFile: Upload
  city: IdInput
  clearAvatar: Boolean
  color: String
  name: String
  role: String
}

input DriverWorkingDayInput {
  day: String
  finishedAt: String
  location: LocationInput
  orderTruck: IdInput
  startedAt: String
  status: String
}

input FeeCreateInput {
  amountFrom: Float
  amountTo: Float
  code: OneTimeCodeEnum
  dateFrom: String
  dateTo: String
  deliveryMethods: [IdInput!]
  distanceFrom: Float
  distanceTo: Float
  durationFrom: Float
  durationTo: Float
  exportCode: String
  loadFrom: Float
  loadTo: Float
  mergeName: String
  name: String!
  partner: IdInput
  pickup: FeePickupEnum
  product: IdInput
  productTypes: [IdInput!]
  quantityFrom: Float
  quantitySequence: String
  quantityTo: Float
  rrule: String
  serviceName: String!
  sortOrder: Int
  type: FeeTypeEnum!
}

input FeePriceCreateInput {
  city: IdInput
  contractor: IdInput
  countryState: IdInput
  fee: IdInput!
  group: PriceGroupEnum
  price: PriceInput!
  supplier: IdInput
}

input FeePriceInput {
  city: IdInput
  content: String
  contractor: IdInput
  countryState: IdInput
  currency: String
  fee: IdInput!
  formula: IdInput
  formulaArguments: JSON
  supplier: IdInput
  value: Float
}

input FeePriceUpdateInput {
  city: IdInput
  contractor: IdInput
  countryState: IdInput
  formula: IdInput
  formulaArguments: JSON
  id: ID!
  price: PriceInput
  supplier: IdInput
}

input FeeUpdateInput {
  amountFrom: Float
  amountTo: Float
  clearProduct: Boolean
  code: OneTimeCodeEnum
  dateFrom: String
  dateTo: String
  deliveryMethods: [IdInput!]
  distanceFrom: Float
  distanceTo: Float
  durationFrom: Float
  durationTo: Float
  exportCode: String
  id: ID!
  loadFrom: Float
  loadTo: Float
  mergeName: String
  name: String
  partner: IdInput
  pickup: FeePickupEnum
  product: IdInput
  productTypes: [IdInput!]
  quantityFrom: Float
  quantitySequence: String
  quantityTo: Float
  rrule: String
  serviceName: String
  sortOrder: Int
}

input FromToInput {
  from: String!
  to: String!
}

input IdInput {
  id: ID!
}

input IdentityAddInput {
  active: Boolean!
  email: String
  phone: String
}

input IdentityChangeInput {
  password: FromToInput
}

input IdentityEmailInput {
  email: String!
  password: String!
}

input IdentityOauth2Input {
  provider: OauthProviderEnum!
  token: String!
}

input IdentityPhoneInput {
  password: String!
  phone: String!
}

input IdentityRemoveInput {
  email: String
  phone: String
}

input IdentityUpdateInput {
  add: [IdentityAddInput!]
  change: [IdentityChangeInput!]
  remove: [IdentityRemoveInput!]
}

input InventoryInput {
  plant: IdInput!
  productType: IdInput!
  quantity: Int!
}

input LocationInput {
  latitude: Float!
  longitude: Float!
}

input MemberInput {
  avatar: Upload
  email: String!
  name: String!
}

input OptionCreateInput {
  category: IdInput!
  exportCode: String
  group: String
  image: Upload
  name: String
  oneOfGroup: Boolean
  required: Boolean
  serviceName: String
  sortOrder: Int
}

input OptionPriceCreateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  option: IdInput!
  plant: IdInput
  price: PriceInput!
  product: IdInput
  supplier: IdInput
}

input OptionPriceInput {
  city: IdInput
  content: String
  contractor: IdInput
  currency: String
  formula: IdInput
  formulaArguments: JSON
  option: IdInput!
  plant: IdInput
  product: IdInput
  supplier: IdInput
  value: Float
}

input OptionPriceUpdateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  id: ID!
  plant: IdInput
  price: PriceInput
  product: IdInput
  supplier: IdInput
}

input OptionUpdateInput {
  clearImage: Boolean
  exportCode: String
  group: String
  id: ID!
  image: Upload
  name: String
  oneOfGroup: Boolean
  required: Boolean
  serviceName: String
  sortOrder: Int
}

input OrderCancelReasonType {
  details: String
  value: String!
}

input OrderCreateInput {
  additional: JSON
  address: AddressInput!
  adminNotes: String
  currency: String
  deliveryDetails: String
  deliveryItems: [[OrderDeliveryItemInput!]!]
  deliveryMethod: String
  deliveryTime: String
  deliveryWindow: Int
  fees: [OrderFeePriceInput!] = []
  options: [OrderOptionPriceInput!] = []
  paymentMode: OrderPaymentModeEnum
  pickup: Boolean
  pickupTime: String
  priceMode: OrderPriceModeEnum
  product: ProductInput!
  project: IdInput
  projectType: String
  purchaseNumber: String
  requested: Boolean
  timeBetweenTrucks: Int = 0
  toBeConfirmed: Boolean
  totalPrice: Float!
  trucks: [Float!]
  trucksSecondary: [Float!]
}

input OrderDeliveryItemInput {
  id: ID
  productType: IdInput
  quantity: Float
  status: DeliveryItemStatusEnum
}

input OrderFeePriceInput {
  content: String
  id: ID!
  price: IdInput
  value: Float
}

input OrderImageInput {
  image: ResourceInput!
  type: String!
}

input OrderOptionPriceInput {
  content: String
  id: ID!
  price: IdInput
  quantity: Float
  value: Float
}

input OrderPreparatoryConfigInput {
  address: AddressInput
  category: IdInput
  deliveryMethod: String
  deliveryTime: String
  fees: [OrderFeePriceInput!]
  options: [OrderOptionPriceInput!]
  pickup: Boolean
  plant: IdInput
  productPrices: [ProductPriceInput!]
  project: IdInput
  skids: [OrderSkidPriceInput!]
  timeBetweenTrucks: Int
  trucks: [Float!]
  trucksSecondary: [Float!]
}

input OrderRateInput {
  brokrete: Float
  driver: Float
  id: ID!
  product: Float
  supplier: Float
}

input OrderResourceInput {
  resource: ResourceInput!
  type: OrderResourceTypeEnum!
}

input OrderSkidPriceInput {
  content: String
  id: ID!
  price: IdInput
  quantity: Float
  value: Float
}

input OrderUpdateInput {
  additional: JSON
  address: AddressInput
  adminNotes: String
  deliveryDetails: String
  deliveryItems: [[OrderDeliveryItemInput!]!]
  deliveryMethod: String
  """

  assigns plant to order_truck
  with driver and truck
  """
  deliveryPlants: [IdInput]
  deliveryTime: String
  deliveryTrucks: [IdInput]
  deliveryWindow: Int
  desiredSlump: Int
  drivers: [IdInput]
  fees: [OrderFeePriceInput!]
  id: ID!
  options: [OrderOptionPriceInput!]
  paymentMode: OrderPaymentModeEnum
  pickupTime: String
  priceMode: OrderPriceModeEnum
  product: ProductInput
  project: IdInput
  projectType: String
  purchaseNumber: String
  recalculateFees: Boolean
  state: OrderStateEnum
  timeBetweenTrucks: Int
  timeRequestedWithTruck: Int
  totalPrice: Float
  truckStatus: OrderTruckStatusEnum
  trucks: [Float!]
  trucksSecondary: [Float!]
  unloadingMethod: String
  unloadingMethodDetails: String
}

input OrderValidateInput {
  address: AddressInput!
  deliveryTime: String
  fees: [IdInput!]
  id: ID
  options: [IdInput!]
  pickup: Boolean
  product: ProductInput!
  timeBetweenTrucks: Int
  totalPrice: Float
  trucks: [Float!]
  trucksSecondary: [Float!]
}

input PartnerAccountBankRequisitesInput {
  accountHolderName: String
  accountNumber: String
  bankNumber: String
  routingNumber: String
}

input PartnerConfigInput {
  notificationEmail: String
  notificationPhone: String
  oneSignalApiKey: String
  oneSignalAppId: String
  slackBilldWebhookUrl: String
  slackOrderWebhookUrl: String
}

input PartnerContractorConnectInput {
  accountInfo: String
  partner: IdInput!
}

input PartnerContractorInput {
  country: IdInput
  email: String
  id: ID
  name: String
}

input PartnerContractorInviteInput {
  accountingEmail: String
  companyAddress: String
  companyName: String
  companySize: String
  contractorType: String
  country: IdInput
  creditAccount: Boolean
  creditLimit: Float
  customField1: String
  customField2: String
  email: String!
  exportCode: String
  manager1Email: String
  manager1Name: String
  manager1Phone: String
  manager2Email: String
  manager2Name: String
  manager2Phone: String
  manager3Email: String
  manager3Name: String
  manager3Phone: String
  manager4Email: String
  manager4Name: String
  manager4Phone: String
  name: String
  phone: String
  priceGroup: PriceGroupEnum
  secondaryEmail: String
  secondaryPhone: String
  skipInviteEmail: Boolean
}

input PartnerContractorsInput {
  add: [PartnerContractorInput!]
  remove: [IdInput!]
}

input PartnerCreateInput {
  address: AddressInput
  code: String!
  countryState: IdInput!
  description: String
  email: String!
  logo: Upload
  name: String!
  phone: String
  website: String
}

input PartnerDriverInviteInput {
  city: IdInput
  color: String
  email: String!
  name: String
  phone: String
}

input PartnerDriversInput {
  add: [IdInput!]
  remove: [IdInput!]
}

input PartnerMemberCreateInput {
  member: MemberInput!
  partner: IdInput!
  roles: [IdInput!]
}

input PartnerProductCategoriesInput {
  add: [PartnerProductCategoryInput!]
  change: [PartnerProductCategoryInput!]
  remove: [IdInput!]
}

input PartnerProductCategoryInput {
  active: Boolean
  id: ID!
  sortOrder: Int
}

input PartnerProductTypeInput {
  active: Boolean
  id: ID!
  sortOrder: Int
}

input PartnerProductTypesInput {
  add: [PartnerProductTypeInput!]
  change: [PartnerProductTypeInput!]
  remove: [IdInput!]
}

input PartnerSuppliersInput {
  add: [IdInput!]
  remove: [IdInput!]
}

input PartnerTaxCreateInput {
  code: String
  countryState: IdInput
  displayName: String
  fee: IdInput
  internal: Boolean
  name: String
  rate: Float
  visible: Boolean
}

input PartnerTaxUpdateInput {
  code: String
  countryState: IdInput
  displayName: String
  id: ID
  internal: Boolean
  name: String
  rate: Float
  visible: Boolean
}

input PartnerUpdateInput {
  address: AddressInput
  allowCreditCard: Boolean
  allowOffline: Boolean
  banner: Upload
  caption: String
  clearBanner: Boolean
  clearLargeLogo: Boolean
  clearLogo: Boolean
  code: String
  config: PartnerConfigInput
  contractors: PartnerContractorsInput
  currency: String
  description: String
  drivers: PartnerDriversInput
  email: String
  fundsAvailablePeriod: Int
  id: ID
  inviteContractorBanner: Upload
  inviteManagerBanner: Upload
  largeLogo: Upload
  logo: Upload
  name: String
  offlineBanks: [PartnerAccountBankRequisitesInput!]
  payoutFeeAdminCoef: Float
  payoutFeeAppCoef: Float
  payoutFeePartnerAppCoef: Float
  payoutFeeWebCoef: Float
  phone: String
  prettyIdPrefix: String
  productCategories: PartnerProductCategoriesInput
  productTypes: PartnerProductTypesInput
  serviceEmail: String
  servicePhone: String
  shortCaption: String
  signatureConsentText: String
  suppliers: PartnerSuppliersInput
  termsAndConditions: String
  website: String
}

input PaymentInput {
  amount: Float
  cardInfo: CardInfoInput
  currency: String
  paymentMethod: IdInput
  "Stripe PM id"
  paymentMethodId: String
  provider: String
  transactionId: String
}

input PaymentLinkCreateInput {
  orders: [IdInput!]!
}

input PaymentMethodCardInput {
  brand: String
  cardholderName: String
  country: String
  cvv: String
  expMonth: Int
  expYear: Int
  last4: String
  number: String
  paymentMethod: Boolean
  provider: String
  source: JSON
  uid: String
  zip: String
}

input PlantCreateInput {
  address: AddressInput!
  city: IdInput!
  color: String
  customFields: [PlantCustomFieldInput!]
  deliveryRadius: Float!
  description: String
  email: String
  image: ResourceInput
  invoiceAddress: String
  name: String
  openHours: [[Float!]!]
  phone: String
  serviceName: String
  supplier: IdInput
}

input PlantCustomFieldInput {
  name: String!
  value: String!
}

input PlantDeliveryMethodsInput {
  category: IdInput!
  values: [IdInput!]!
}

input PlantDiscountInput {
  product: IdInput!
  values: [PlantDiscountItemInput!]!
}

input PlantDiscountItemInput {
  amount: Float!
  discount: Float!
}

input PlantDriverInput {
  add: [PlantDriverItemInput!]
  remove: [IdInput!]
}

input PlantDriverItemInput {
  id: ID!
}

input PlantFeeDeleteInput {
  force: Boolean
  id: ID!
}

input PlantFeeInput {
  active: Boolean
  id: ID!
}

input PlantFeePriceDeleteInput {
  contractor: IdInput
  fee: IdInput
  id: ID
  product: IdInput
}

input PlantFeePriceUpdateInput {
  contractor: IdInput
  fee: IdInput!
  price: PriceInput!
  product: IdInput
}

input PlantFeePricesInput {
  change: [PlantFeePriceUpdateInput!]
  remove: [PlantFeePriceDeleteInput!]
}

input PlantFeesInput {
  add: [PlantFeeInput!]
  change: [PlantFeeInput!]
  remove: [PlantFeeDeleteInput!]
}

input PlantOptionInput {
  active: Boolean
  id: ID!
}

input PlantOptionsInput {
  add: [PlantOptionInput!]
  change: [PlantOptionInput!]
  remove: [IdInput!]
}

input PlantProductDecorateInput {
  active: Boolean
  id: ID!
}

input PlantProductDecoratesInput {
  add: [PlantProductDecorateInput!]
  change: [PlantProductDecorateInput!]
  remove: [IdInput!]
}

input PlantProductTypeInput {
  active: Boolean
  id: ID!
}

input PlantProductTypesInput {
  add: [PlantProductTypeInput!]
  change: [PlantProductTypeInput!]
  remove: [IdInput!]
}

input PlantSettingsAvailabilityTimesInput {
  category: IdInput!
  deliveryWindow: Int
  step: Int!
  values: [[Int!]!]!
}

input PlantSettingsBookingInput {
  cancelingFeePrice: PriceInput
  category: IdInput!
  holdingFeePrice: PriceInput
  lockToCancelTime: Int
  lockToHoldTime: Int
  lockToModifyTime: Int
  maxCountToHold: Int
  pickup: Boolean
}

input PlantSettingsInput {
  availabilityTimes: [PlantSettingsAvailabilityTimesInput!]
  booking: [PlantSettingsBookingInput!]
  quantities: [PlantSettingsQuantitiesInput!]
  termsAndConditions: [PlantSettingsTermsAndConditionsInput!]
}

input PlantSettingsQuantitiesInput {
  balanceTruck: Float
  category: IdInput!
  deliveryMethod: IdInput
  maxTrucksQuantity: Float
  minOrderAmount: Float
  minOrderQuantity: Float
  minTruckCapacity: Float
  secondaryMinTruckCapacity: Float
  secondaryStep: Float
  secondaryTruckCapacity: Float
  secondaryUnits: String
  step: Float
  truckCapacity: Float
  units: String
}

input PlantSettingsTermsAndConditionsInput {
  additionalCharges: String
  category: IdInput!
  contractorRequirements: String
  deliveryDisclaimers: String
  note: String
  policy: String
}

input PlantUpdateInput {
  address: AddressInput
  city: IdInput
  color: String
  customFields: [PlantCustomFieldInput!]
  deliveryMethods: PlantDeliveryMethodsInput
  deliveryRadius: Float
  description: String
  discounts: PlantDiscountInput
  drivers: PlantDriverInput
  email: String
  feePrices: PlantFeePricesInput
  fees: PlantFeesInput
  id: ID!
  image: ResourceInput
  invoiceAddress: String
  name: String
  openHours: [[Float!]!]
  optionPrices: [OptionPriceCreateInput!]
  options: [IdInput!]
  optionsAcr: PlantOptionsInput
  phone: String
  prettyIdPrefix: String
  prettyIdSuffixForSelfPickup: String
  productDecoratePrices: [ProductDecoratePriceCreateInput!]
  productDecorates: [IdInput!]
  productDecoratesAcr: PlantProductDecoratesInput
  productTypePrices: [ProductTypePriceCreateInput!]
  productTypes: [IdInput!]
  productTypesAcr: PlantProductTypesInput
  serviceName: String
  settings: PlantSettingsInput
  trucks: [IdInput!]
}

input PriceInput {
  content: String
  currency: String
  formula: IdInput
  formulaArguments: JSON
  value: Float
}

input ProductCategoryCreateInput {
  exportCode: String
  image: Upload
  industry: String
  name: String
  serviceName: String
  sortOrder: Int
}

input ProductCategoryUpdateInput {
  active: Boolean
  exportCode: String
  id: ID!
  image: Upload
  name: String
  serviceName: String
  sortOrder: Int
}

input ProductDecorateCreateInput {
  category: IdInput
  color: String
  exportCode: String
  image: Upload
  name: String
  serviceName: String
  sortOrder: Int
}

input ProductDecoratePriceCreateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  plant: IdInput
  price: PriceInput!
  productDecorate: IdInput!
  productType: IdInput
  supplier: IdInput
}

input ProductDecoratePriceUpdateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  id: ID!
  plant: IdInput
  price: PriceInput
  supplier: IdInput
}

input ProductDecorateUpdateInput {
  active: Boolean
  clearImage: Boolean
  color: String
  exportCode: String
  id: ID!
  image: Upload
  name: String
  serviceName: String
  sortOrder: Int
}

input ProductInput {
  id: ID
  prices: [ProductPriceInput!]
}

input ProductPriceInput {
  decorate: IdInput
  decoratePrice: IdInput
  decoratePriceValue: Float
  quantity: Float
  type: IdInput
  typePrice: IdInput
  typePriceValue: Float
}

input ProductTypeCombinationAddInput {
  description: String
  modifications: [IdInput!]!
  name: String
}

input ProductTypeCombinationChangeInput {
  description: String
  id: ID!
  modifications: [IdInput!]
  name: String
}

input ProductTypeCombinationInput {
  add: [ProductTypeCombinationAddInput!]
  change: [ProductTypeCombinationChangeInput!]
  remove: [IdInput!]
}

input ProductTypeCreateCustomInput {
  description: String
  descriptionImages: [Upload!]
  descriptionResources: [ProductTypeImageAddInput!]
  image: Upload
  name: String!
  product: IdInput!
  specification: Upload
}

input ProductTypeCreateInput {
  characteristics: [[String!]!]
  colors: [IdInput!]
  description: String
  descriptionImages: [Upload!]
  descriptionResources: [ProductTypeImageAddInput!]
  exportCode: String
  group: String
  image: Upload
  name: String
  options: ProductTypeOptionsInput
  product: IdInput!
  serviceName: String
  shortDescription: String
  sortOrder: Int
  specification: Upload
  tags: [String!]
}

input ProductTypeImageAcrInput {
  add: [ProductTypeImageAddInput!]
  change: [ProductTypeImageChangeInput!]
  remove: [IdInput!]
}

input ProductTypeImageAddInput {
  description: String
  image: Upload!
  sortOrder: Int
}

input ProductTypeImageChangeInput {
  description: String
  id: ID!
  sortOrder: Int
}

input ProductTypeModificationAddInput {
  label: String
  type: String!
  values: [ProductTypeModificationAddItemInput!]!
}

input ProductTypeModificationAddItemInput {
  characteristics: [[String!]!]
  color: String
  description: String
  image: Upload
  imageCaption: String
  imageFullscreen: Boolean
  name: String!
  numeric: Int
  sortOrder: Int
}

input ProductTypeModificationChangeInput {
  label: String
  type: String!
  values: [ProductTypeModificationChangeItemInput!]!
}

input ProductTypeModificationChangeItemInput {
  characteristics: [[String!]!]
  color: String
  description: String
  id: ID!
  image: Upload
  imageCaption: String
  imageFullscreen: Boolean
  name: String
  numeric: Int
  sortOrder: Int
}

input ProductTypeModificationInput {
  add: [ProductTypeModificationAddInput!]
  change: [ProductTypeModificationChangeInput!]
  remove: [IdInput!]
}

input ProductTypeOptionValueInput {
  description: String
  id: ID
  value: String
}

input ProductTypeOptionsInput {
  label: String
  values: [ProductTypeOptionValueInput!]!
}

input ProductTypePriceCreateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  plant: IdInput
  price: PriceInput!
  productType: IdInput!
  supplier: IdInput
}

input ProductTypePriceUpdateInput {
  city: IdInput
  contractor: IdInput
  group: PriceGroupEnum
  id: ID!
  plant: IdInput
  price: PriceInput
  supplier: IdInput
}

input ProductTypeUpdateInput {
  active: Boolean
  addDescriptionImages: [Upload!]
  characteristics: [[String!]!]
  colors: [IdInput!]
  description: String
  descriptionResources: ProductTypeImageAcrInput
  exportCode: String
  group: String
  id: ID!
  image: Upload
  modifications: ProductTypeModificationInput
  name: String
  optionCombinations: ProductTypeCombinationInput
  options: ProductTypeOptionsInput
  removeDescriptionImages: [String!]
  serviceName: String
  shortDescription: String
  sortOrder: Int
  specification: Upload
  tags: [String!]
  virtualPrice: ProductTypeVirtualPriceInput
}

input ProductTypeVirtualPriceInput {
  unit: String
  value: String
}

input ProjectCreateInput {
  address: AddressInput!
  daysToStart: Int
  estimatedValue: Float
  exportCode: String
  kind: String
  name: String!
  plant: IdInput
  priceLocked: Boolean
  status: ProjectTypeEnum
  taxable: Boolean
  type: String!
  workType: String
}

input ProjectImageInput {
  image: ResourceInput!
}

input ProjectPriceGroupCreateInput {
  group: PriceGroupEnum!
  plant: IdInput
  product: IdInput
}

input ProjectPricesUpdateInput {
  feePrices: [FeePriceCreateInput!]
  id: ID!
  optionPrices: [OptionPriceCreateInput!]
  productDecoratePrices: [ProductDecoratePriceCreateInput!]
  productTypePrices: [ProductTypePriceCreateInput!]
}

input ProjectResourceInput {
  resource: ResourceInput!
  type: ProjectResourceTypeEnum!
}

input ProjectUpdateInput {
  additionalInfo: String
  address: AddressInput
  clientEmail: String
  clientName: String
  clientPhone: String
  daysToStart: Int
  estimatedValue: Float
  exportCode: String
  id: ID!
  kind: String
  name: String
  plant: IdInput
  priceLocked: Boolean
  status: ProjectTypeEnum
  taxable: Boolean
  taxableApproved: Boolean
  type: String
  workType: String
}

input QuestionaryTargetInput {
  id: ID!
  name: QuestionaryTargetNameEnum!
}

input RegionInput {
  deltaLatitude: Float
  deltaLongitude: Float
  latitude: Float!
  longitude: Float!
  radius: Float
}

"Input object for files, images e.t.c"
input ResourceInput {
  "base64 file content"
  base64: String
  "IO of a new file"
  file: Upload
  "remove existing resource"
  remove: Boolean
  "url of a new file"
  source: String
}

input ServiceRequestInfoInput {
  city: String
  companyName: String
  details: String
  email: String!
  name: String
  phone: String
  position: String
  productsManage: String
  productsSell: String
  reason: String!
  source: String
  typeOfIndustry: String
  websiteUrl: String
}

input SupplierCreateInput {
  name: String!
}

input SupplierMemberCreateInput {
  member: MemberInput!
  supplier: IdInput!
}

input SupplierUpdateInput {
  deliveryInstructions: String
  id: ID
  name: String
  productCategories: PartnerProductCategoriesInput
  productTypes: PartnerProductTypesInput
}

input TruckCreateInput {
  deviceId: String
  driver: IdInput
  name: String!
  plant: IdInput
  productCategories: [IdInput!]
  type: String
}

input TruckRemoveInput {
  truck: IdInput!
}

input TruckUpdateInput {
  deviceId: String
  driver: IdInput
  location: LocationInput
  name: String
  plant: IdInput
  productCategories: [IdInput!]
  text: String
  truck: IdInput!
  type: String
}

input WidgetCreateInput {
  align: String
  backgroundColor: String
  description: String
  design: WidgetDesignEnum
  image: Boolean
  imageBackground: Boolean
  imageSize: Int
  logo: Upload
  mode: WidgetModeEnum
  partner: IdInput
  shift: Int
  title: String
  titleColor: String
  type: WidgetTypeEnum
  usePartnerLogo: Boolean
}

input WidgetUpdateInput {
  align: String
  backgroundColor: String
  description: String
  design: WidgetDesignEnum
  id: ID!
  image: Boolean
  imageBackground: Boolean
  imageSize: Int
  logo: Upload
  mode: WidgetModeEnum
  partner: IdInput
  shift: Int
  title: String
  titleColor: String
  type: WidgetTypeEnum
  usePartnerLogo: Boolean
}
